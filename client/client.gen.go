// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AccountRole.
const (
	AccountRoleN0 AccountRole = 0
	AccountRoleN1 AccountRole = 1
	AccountRoleN2 AccountRole = 2
	AccountRoleN3 AccountRole = 3
	AccountRoleN4 AccountRole = 4
)

// Defines values for DeviceVendor.
const (
	DeviceVendorN0 DeviceVendor = 0
	DeviceVendorN1 DeviceVendor = 1
	DeviceVendorN2 DeviceVendor = 2
	DeviceVendorN3 DeviceVendor = 3
)

// Defines values for EventState.
const (
	EventStateN0 EventState = 0
	EventStateN1 EventState = 1
	EventStateN2 EventState = 2
)

// Defines values for FileSystem.
const (
	FileSystemN0  FileSystem = 0
	FileSystemN1  FileSystem = 1
	FileSystemN10 FileSystem = 10
	FileSystemN11 FileSystem = 11
	FileSystemN2  FileSystem = 2
	FileSystemN3  FileSystem = 3
	FileSystemN4  FileSystem = 4
	FileSystemN5  FileSystem = 5
	FileSystemN6  FileSystem = 6
	FileSystemN7  FileSystem = 7
	FileSystemN8  FileSystem = 8
	FileSystemN9  FileSystem = 9
)

// Defines values for Month.
const (
	MonthN1  Month = 1
	MonthN10 Month = 10
	MonthN11 Month = 11
	MonthN12 Month = 12
	MonthN2  Month = 2
	MonthN3  Month = 3
	MonthN4  Month = 4
	MonthN5  Month = 5
	MonthN6  Month = 6
	MonthN7  Month = 7
	MonthN8  Month = 8
	MonthN9  Month = 9
)

// Defines values for PowerCommand.
const (
	PowerCommandN0 PowerCommand = 0
	PowerCommandN1 PowerCommand = 1
	PowerCommandN2 PowerCommand = 2
	PowerCommandN3 PowerCommand = 3
)

// Defines values for PowerState.
const (
	PowerStateN0 PowerState = 0
	PowerStateN1 PowerState = 1
	PowerStateN2 PowerState = 2
	PowerStateN3 PowerState = 3
)

// Defines values for RaidType.
const (
	RaidTypeN0 RaidType = 0
	RaidTypeN1 RaidType = 1
	RaidTypeN2 RaidType = 2
	RaidTypeN3 RaidType = 3
)

// Defines values for ServiceType.
const (
	ServiceTypeN0 ServiceType = 0
	ServiceTypeN1 ServiceType = 1
	ServiceTypeN2 ServiceType = 2
	ServiceTypeN3 ServiceType = 3
	ServiceTypeN4 ServiceType = 4
	ServiceTypeN5 ServiceType = 5
)

// Defines values for Status.
const (
	StatusN0 Status = 0
	StatusN1 Status = 1
	StatusN2 Status = 2
	StatusN3 Status = 3
	StatusN4 Status = 4
)

// Defines values for StorageType.
const (
	N0 StorageType = 0
	N1 StorageType = 1
	N2 StorageType = 2
	N3 StorageType = 3
)

// Account defines model for Account.
type Account struct {
	AccountLocked      *bool        `json:"accountLocked,omitempty"`
	AccountName        *string      `json:"accountName"`
	AccountRole        *AccountRole `json:"accountRole,omitempty"`
	Created            *time.Time   `json:"created,omitempty"`
	Deleted            *time.Time   `json:"deleted"`
	ExternalIdentifier *string      `json:"externalIdentifier"`
	Id                 *int64       `json:"id,omitempty"`
	ObjectType         *string      `json:"objectType"`

	// StripeId The ID for the Stripe customer account
	StripeId   *string `json:"stripeId"`
	UseBilling *bool   `json:"useBilling,omitempty"`
}

// AccountRole defines model for AccountRole.
type AccountRole int32

// ApiResponse Base class for all API responses
type ApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// AttachToNetworkRequest Details for attaching an instance to a network
type AttachToNetworkRequest struct {
	// NetworkId Id of the network to attach to the instance
	NetworkId *string `json:"networkId"`
}

// AttachToNetworkResponse Response when attaching a network to an instance
type AttachToNetworkResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// AttachVolumeRequest defines model for AttachVolumeRequest.
type AttachVolumeRequest struct {
	// InstanceId *Optional* - The id of the instance to attach the volume to
	InstanceId *int64 `json:"instanceId,omitempty"`

	// MountPoint The location where the volume will be mounted on the instance
	MountPoint string `json:"mountPoint"`

	// RegionId The region of both the volume and the instance
	RegionId string `json:"regionId"`

	// VolumeId The id of the volume to attach
	VolumeId string `json:"volumeId"`
}

// AttachVolumeResponse Response to the request to attach a volume to an instance
type AttachVolumeResponse struct {
	// InstanceId The id of the instance the volume is attached to
	InstanceId *int64 `json:"instanceId,omitempty"`

	// MountPoint The location where the volume is mounted on the instance
	MountPoint *string `json:"mountPoint"`

	// RegionId The id of the region
	RegionId *string `json:"regionId"`

	// VolumeId The id of the volume to attach
	VolumeId *string `json:"volumeId"`
}

// AttachVolumeResponseApiResponse Standard response object for all API requests with additional data
type AttachVolumeResponseApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Response to the request to attach a volume to an instance
	Result *AttachVolumeResponse `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// CalculatePriceRequest defines model for CalculatePriceRequest.
type CalculatePriceRequest struct {
	Disks       *map[string]*string `json:"disks"`
	MemoryGb    *float64            `json:"memoryGb,omitempty"`
	NetworkGbps *float64            `json:"networkGbps,omitempty"`
	RegionId    *string             `json:"regionId"`
	Reserved    *bool               `json:"reserved,omitempty"`
	ServiceType *ServiceType        `json:"serviceType,omitempty"`
	TierId      *string             `json:"tierId"`
}

// CalculatePriceResponse Provides a breakdown of the pricing for a service
type CalculatePriceResponse struct {
	// Drives The price details for the drive configuration
	Drives *[]DrivePriceResponse `json:"drives"`

	// HourlyPrice The total hourly price for the service
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`

	// Memory Details about the price of a memory option
	Memory *MemoryPriceResponse `json:"memory,omitempty"`

	// MonthlyPrice The total monthly price for the service
	MonthlyPrice *float64 `json:"monthlyPrice,omitempty"`

	// Network Details about the price of a network configuration
	Network     *NetworkPriceResponse `json:"network,omitempty"`
	RegionId    *string               `json:"regionId"`
	Reserved    *bool                 `json:"reserved,omitempty"`
	ServiceType *ServiceType          `json:"serviceType,omitempty"`

	// TierHourlyPrice The base hourly price for the tier
	TierHourlyPrice *float64 `json:"tierHourlyPrice,omitempty"`
	TierId          *string  `json:"tierId"`

	// TierMonthlyPrice The base monthly price for the tier
	TierMonthlyPrice *float64 `json:"tierMonthlyPrice,omitempty"`
}

// CloudService Represents a cloud service, which is a virtual machine.
type CloudService struct {
	Account            *Account   `json:"account,omitempty"`
	BillingId          *string    `json:"billingId"`
	ContractId         *int64     `json:"contractId"`
	Created            *time.Time `json:"created,omitempty"`
	Deleted            *time.Time `json:"deleted"`
	DisplayName        *string    `json:"displayName"`
	ExternalIdentifier *string    `json:"externalIdentifier"`
	Id                 *int64     `json:"id,omitempty"`

	// Image Details about the OS image applied to a service
	Image *Image `json:"image,omitempty"`

	// ImageId ID for the OS image used to create
	ImageId *string `json:"imageId"`

	// IpAddresses The IP addresses assigned to the service
	IpAddresses *[]string    `json:"ipAddresses"`
	MetalDevice *MetalDevice `json:"metalDevice,omitempty"`

	// ObjectType Object type pneumonic
	ObjectType      *string `json:"objectType"`
	ParentServiceId *int64  `json:"parentServiceId"`

	// PowerState Represents the power state of a service.
	PowerState *PowerState `json:"powerState,omitempty"`
	ProjectId  *int64      `json:"projectId,omitempty"`

	// RateId UID for the cost rate for this service as it's stored in the billing system
	RateId         *openapi_types.UUID `json:"rateId"`
	Region         *Region             `json:"region,omitempty"`
	RegionId       *string             `json:"regionId"`
	ReservePricing *bool               `json:"reservePricing"`
	ServiceType    *ServiceType        `json:"serviceType,omitempty"`
	Sku            *string             `json:"sku"`

	// Status Describes the status of a service
	Status *Status   `json:"status,omitempty"`
	Tags   *[]string `json:"tags"`

	// Tier Tier for a cloud service.
	Tier   *CloudTier `json:"tier,omitempty"`
	TierId *string    `json:"tierId"`
}

// CloudServiceApiResponse Standard response object for all API requests with additional data
type CloudServiceApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Represents a cloud service, which is a virtual machine.
	Result *CloudService `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// CloudServiceIEnumerableApiResponse Standard response object for all API requests with additional data
type CloudServiceIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]CloudService `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// CloudTier Tier for a cloud service.
type CloudTier struct {
	Hidden *bool `json:"hidden,omitempty"`

	// Id ID of the tier
	Id *string `json:"id"`

	// Memory Amount of memory for the VM
	Memory   *int32 `json:"memory,omitempty"`
	Transfer *int32 `json:"transfer,omitempty"`

	// Vcpus Number of virtual CPUs for the VM
	Vcpus *int32 `json:"vcpus,omitempty"`
}

// CloudTierIEnumerableApiResponse Standard response object for all API requests with additional data
type CloudTierIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]CloudTier `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// CreateInstanceRequest defines model for CreateInstanceRequest.
type CreateInstanceRequest struct {
	BootSize *int32 `json:"bootSize,omitempty"`

	// DisplayName Display name for the service.
	DisplayName *string `json:"displayName"`

	// ImageId The image to use when creating this service.  Available images can be retrieved via the images endpoint.
	ImageId *string `json:"imageId"`

	// Password The password to be set for the root user.  If not provided, a random password will be generated.
	Password  *string `json:"password"`
	ProjectId *int64  `json:"projectId,omitempty"`

	// RegionId The region this service should be created in (for example: US-EAST-1).  If an invalid region is provided you will receive a 400 Bad Request.  Use the Regions endpoint to retrieve available regions.
	RegionId string `json:"regionId"`

	// SshKeyIds The SSH key ids to be added to the service.  These keys will be added to the authorized_keys file for the root user.
	SshKeyIds *[]int64  `json:"sshKeyIds"`
	SshKeys   *[]SshKey `json:"sshKeys"`
	Tags      *[]string `json:"tags"`

	// TierId The service tier to be created.  For metal, this is typically the server config.  For example: 7302p-64g would create a Epyc 7302P system with 64G of ram.  Tier availability can be retrieved using the regions endpoints.
	TierId string `json:"tierId"`

	// TierObj Tier for a cloud service.
	TierObj *CloudTier `json:"tierObj,omitempty"`

	// UserData Additional user data
	UserData *string `json:"userData"`
}

// CreateMetalRequest Request details for creating a metal service.
type CreateMetalRequest struct {
	// Disks Dictionary of disk names and sizes in GB. If not specified, the default configuration for the metal tier will
	// be used.
	//
	// The key is the disk name and the value is the size in GB.  For example:
	//
	//     "disks": {
	//         "nvme0n1": "960g",
	//         "nvme1n1": "960g"
	//     }
	Disks *map[string]*string `json:"disks"`

	// DisplayName Display name for the service.
	DisplayName *string `json:"displayName"`

	// ImageId The image to use when creating this service.  Available images can be retrieved via the images endpoint.
	ImageId *string `json:"imageId"`

	// IpxeUrl If doing an iPXE boot, this is the URL to the script.
	IpxeUrl *string `json:"ipxeUrl"`

	// MemoryGb The amount of memory in GB to be allocated to the service.
	MemoryGb *int32 `json:"memoryGb,omitempty"`

	// Partitions Partitions to be created.  Not specifying this will result in a single root partition being created.
	//
	// Example for specifying partitions:
	//
	//     "partitions": [
	//         {
	//             "name": "nvme0n1-part1",
	//             "device": "nvme0n1",
	//             "sizeBytes": 50000000000
	//         },
	//         {
	//             "name": "nvme0n1-part1",
	//             "device": "nvme0n1",
	//             "sizeBytes": 50000000000
	//         },
	//         {
	//             "name": "nvme1n1-part2",
	//             "device": "nvme1n1"
	//             // If sizeBytes is not specified for a device, the remainder of the space will be used.
	//         }
	//     ]
	Partitions *[]Partition `json:"partitions"`

	// Password The password to be set for the root user.  If not provided, a random password will be generated.
	Password  *string `json:"password"`
	ProjectId *int64  `json:"projectId,omitempty"`

	// Quantity The number of services to be created.  By default, one will be created.
	Quantity *int32 `json:"quantity"`

	// RaidArrays Raid arrays to be created. Can reference physical device names or partitions from mediums of the same class.
	//
	// Example of specifying raid arrays:
	//
	//     "raidArrays": [
	//         {
	//             "name": "md0",
	//             "type": "Raid1",
	//             "members": [
	//                 "nvme0n1-part1",
	//                 "nvme1n1-part1"
	//             ],
	//             "fileSystem": "Ext4",
	//             "mountPoint": "/"
	//         }
	//     ]
	RaidArrays *[]RaidArray `json:"raidArrays"`

	// RegionId The region this service should be created in (for example: US-EAST-1).  If an invalid region is provided you will receive a 400 Bad Request.  Use the Regions endpoint to retrieve available regions.
	RegionId string `json:"regionId"`

	// ReservePricing Denotes if the metal service is being reserved for a whole year. If so, it gets the discounted rate
	ReservePricing *bool `json:"reservePricing,omitempty"`
	// Deprecated:
	SshKeyId *int64 `json:"sshKeyId,omitempty"`

	// SshKeyIds The SSH key ids to be added to the service.  These keys will be added to the authorized_keys file for the root user.
	SshKeyIds *[]int64  `json:"sshKeyIds"`
	SshKeys   *[]SshKey `json:"sshKeys"`
	Tags      *[]string `json:"tags"`

	// TemplateId Template can be specified instead of image, partitions, sshKeyId, and userData.
	TemplateId *int64 `json:"templateId"`

	// TierId The service tier to be created.  For metal, this is typically the server config.  For example: 7302p-64g would create a Epyc 7302P system with 64G of ram.  Tier availability can be retrieved using the regions endpoints.
	TierId string `json:"tierId"`

	// TierObj A metal tier represents the configuration options that have billable
	// implications for a metal service. This includes the CPU, memory, drive,
	// and network options.
	TierObj *MetalTier `json:"tierObj,omitempty"`

	// UserData Additional user data
	UserData *string `json:"userData"`
}

// CreateNetworkRequest Details about the network to be created
type CreateNetworkRequest struct {
	// DisplayName *Optional* - The display name of the network
	DisplayName *string `json:"displayName"`

	// RegionId The id of the region that this network will be set up in
	RegionId *string `json:"regionId"`

	// V4Subnet The IPv4 network address. For example: 10.99.0.0
	V4Subnet *string `json:"v4Subnet"`

	// V4SubnetMask The number of bits for the netmask in CIDR notation. For example: 24
	V4SubnetMask *string `json:"v4SubnetMask"`
}

// CreateNetworkResponse Details about the newly created network
type CreateNetworkResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Details about the newly created network
	Result *CreateNetworkResponseDetails `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// CreateNetworkResponseDetails Details about the newly created network
type CreateNetworkResponseDetails struct {
	// DateCreated The timestamp for when the network was created
	DateCreated *time.Time `json:"dateCreated,omitempty"`

	// DisplayName The display name of the network
	DisplayName *string `json:"displayName"`

	// Id The unique id for the network
	Id *string `json:"id"`

	// RegionId The region id for the network
	RegionId *string `json:"regionId"`

	// V4Subnet The IPv4 network address. For example: 10.99.0.0
	V4Subnet *string `json:"v4Subnet"`

	// V4SubnetMask The number of bits for the netmask in CIDR notation. For example: 24
	V4SubnetMask *string `json:"v4SubnetMask"`
}

// CreateVolumeRequest Request to create a storage volume
type CreateVolumeRequest struct {
	// Description *Optional* - The volume description.
	Description *string `json:"description"`

	// DisplayName *Optional* - The name of the storage volume
	DisplayName *string `json:"displayName"`

	// ImageName *Optional* - The name of the image from which you want to create the volume.
	ImageName *string `json:"imageName"`

	// RegionId The data center region where the storage volume will be created
	RegionId string `json:"regionId"`

	// Size The size of the volume, in gibibytes (GiB).
	Size int32 `json:"size"`

	// VolumeType Decide whether you want an HDD or an NVME SSD
	VolumeType *string `json:"volumeType"`
}

// CreateVolumeResponse Response to the request to create a storage volume
type CreateVolumeResponse struct {
	// CreatedAt The time the volume was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description The description of the volume
	Description *string `json:"description"`

	// DisplayName The name of the volume
	DisplayName *string `json:"displayName"`

	// Region The region in which the volume was created
	Region *string `json:"region"`

	// Size The size of the volume
	Size *string `json:"size"`

	// Status The current status of the volume
	Status *string `json:"status"`

	// UpdatedAt The time the volume was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// VolumeId The id of the storage volume
	VolumeId *string `json:"volumeId"`

	// VolumeType The type of the volume. This should be "SSD" or "HDD"
	VolumeType *string `json:"volumeType"`
}

// CreateVolumeResponseApiResponse Standard response object for all API requests with additional data
type CreateVolumeResponseApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Response to the request to create a storage volume
	Result *CreateVolumeResponse `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// DeleteVolumeRequest Details needed to delete a volume
type DeleteVolumeRequest struct {
	// RegionId The region that the volume is in
	RegionId string `json:"regionId"`

	// VolumeId The id of the volume to be deleted
	VolumeId string `json:"volumeId"`
}

// DetachFromNetworkRequest Details for detaching an instance from a network
type DetachFromNetworkRequest struct {
	// NetworkId The ID of the network to detach from
	NetworkId *string `json:"networkId"`
}

// DetachFromNetworkResponse Response when detaching a network from an instance
type DetachFromNetworkResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// DetachVolumeRequest Request to detach a volume from an instance
type DetachVolumeRequest struct {
	// RegionId The region of both the volume and the instance
	RegionId string `json:"regionId"`

	// VolumeId The ID of the volume to detach
	VolumeId string `json:"volumeId"`
}

// DetachVolumeResponse Response to detaching a volume from an instance
type DetachVolumeResponse struct {
	// RegionId The region of both the volume and the instance
	RegionId *string `json:"regionId"`

	// VolumeId The id of the volume to detach
	VolumeId *string `json:"volumeId"`
}

// DetachVolumeResponseApiResponse Standard response object for all API requests with additional data
type DetachVolumeResponseApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Response to detaching a volume from an instance
	Result *DetachVolumeResponse `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// Details Details about the instance networks
type Details struct {
	// Description Human readable description of the network
	Description *string `json:"description"`

	// NetworkId The ID of the network
	NetworkId *string `json:"networkId"`

	// RegionId The ID of the region the network is in
	RegionId *string `json:"regionId"`

	// V4Subnet The IPV4 subnet of the network
	V4Subnet *string `json:"v4Subnet"`

	// V4SubnetMask The IPV4 subnet mask of the network
	V4SubnetMask *string `json:"v4SubnetMask"`
}

// DeviceVendor defines model for DeviceVendor.
type DeviceVendor int32

// DrivePriceResponse Details about the price of a drive option
type DrivePriceResponse struct {
	// HourlyPrice The hourly price for the drive option
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`

	// MonthlyPrice The monthly price for the drive option
	MonthlyPrice *float64 `json:"monthlyPrice,omitempty"`
	Size         *float64 `json:"size,omitempty"`
	Slot         *string  `json:"slot"`
	Unit         *string  `json:"unit"`
}

// DriveSlot Describes a single drive slot and all the drives that can be installed
// in it.
type DriveSlot struct {
	// Default Denotes if the drive slot is the default for the tier.
	Default *string `json:"default"`

	// Id The id of the drive slot. This would be in the format of ```nvme0n1```
	// or ```nvme0n2```
	Id *string `json:"id"`

	// Options Describes the available drives that can be installed in the drive slot.
	Options *[]MetalStorageDevice `json:"options"`
}

// EventState Represents the state of an event.
type EventState int32

// ExtendVolumeRequest Details needed to extend a volume
type ExtendVolumeRequest struct {
	// NewSize The new size for the volume, in gibibytes (GiB)
	NewSize int32 `json:"newSize"`

	// RegionId The region in which the volume is located
	RegionId string `json:"regionId"`

	// VolumeId The id of the volume to be extended
	VolumeId string `json:"volumeId"`
}

// ExtendVolumeResponse Response to extending a volume
type ExtendVolumeResponse struct {
	// NewSize The new size for the volume, in gibibytes (GiB)
	NewSize *int32 `json:"newSize,omitempty"`

	// RegionId The id of the volume to extend
	RegionId *string `json:"regionId"`

	// VolumeId The id of the volume to be extended
	VolumeId *string `json:"volumeId"`
}

// ExtendVolumeResponseApiResponse Standard response object for all API requests with additional data
type ExtendVolumeResponseApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Response to extending a volume
	Result *ExtendVolumeResponse `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// FileSystem The supported filesystems for metal services
type FileSystem int32

// GetInvoiceResponse defines model for GetInvoiceResponse.
type GetInvoiceResponse struct {
	// Message Additional information about the response
	Message *string `json:"message"`

	// Result Details about the invoice
	Result *GetInvoiceResponseDetails `json:"result,omitempty"`

	// Success Flag indicating if the request was successful
	Success *bool `json:"success,omitempty"`
}

// GetInvoiceResponseDetails Details about the invoice
type GetInvoiceResponseDetails struct {
	// AccountId The account id the invoice applies to
	AccountId *int64 `json:"accountId,omitempty"`

	// DatePaid The date that the invoice was paid
	DatePaid *time.Time `json:"datePaid"`

	// DueDate The due date for the invoice
	DueDate *time.Time `json:"dueDate"`

	// Id The id of the invoice
	Id *int64 `json:"id,omitempty"`

	// InvoiceDate The date that the invoice was created
	InvoiceDate *time.Time `json:"invoiceDate"`

	// Lines The individual line items of the invoice
	Lines *[]InvoiceLineResponse `json:"lines"`

	// PayBefore The date to pay the invoice before
	PayBefore *time.Time `json:"payBefore,omitempty"`

	// Status The status of the invoice. One of: Draft, Sent, Paid, Void
	Status *string `json:"status"`

	// Total The total amount of the invoice
	Total *float64 `json:"total,omitempty"`
}

// GetNetworkResponse Details about a single network
type GetNetworkResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Object containing details about the network
	Result *GetNetworkResponseDetails `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// GetNetworkResponseDetails Object containing details about the network
type GetNetworkResponseDetails struct {
	// DateTimeCreated The timestamp for when the network was created
	DateTimeCreated *string `json:"dateTimeCreated"`

	// DisplayName The display name of the network
	DisplayName *string `json:"displayName"`

	// Id A unique id for the network
	Id *string `json:"id"`

	// RegionId The id of the region the network is in
	RegionId *string `json:"regionId"`

	// V4Subnet The IPv4 network address. For example: 10.99.0.0
	V4Subnet *string `json:"v4Subnet"`

	// V4SubnetMask The number of bits for the netmask in CIDR notation. For example: 24
	V4SubnetMask *string `json:"v4SubnetMask"`
}

// Image Details about the OS image applied to a service
type Image struct {
	// DisableCustomizableStorage Reduces customization options for storage. Necessary for Windows
	// and iPXE installs.
	DisableCustomizableStorage *bool `json:"disableCustomizableStorage,omitempty"`

	// DisplayName Human-readable name for the OS image
	DisplayName *string `json:"displayName"`

	// Id The id for the OS image
	Id                 *string `json:"id"`
	MetalCloudInit     *string `json:"metalCloudInit"`
	MetalIdentifier    *string `json:"metalIdentifier"`
	MetalUefiCloudInit *string `json:"metalUefiCloudInit"`

	// OperatingSystemName Base name for the Operating System. Like ```Ubuntu``` or
	// ```Windows Server```
	OperatingSystemName *string `json:"operatingSystemName"`

	// OperatingSystemVersion Specific version of the Operating System. Like ```18.04 LTS``` for
	// Ubuntu or ```2019 Standard``` for Windows
	OperatingSystemVersion *string `json:"operatingSystemVersion"`
}

// ImageIEnumerableApiResponse Standard response object for all API requests with additional data
type ImageIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]Image `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// Interface defines model for Interface.
type Interface struct {
	LinkSpeed  *int32  `json:"linkSpeed,omitempty"`
	MacAddress *string `json:"macAddress"`
	Name       *string `json:"name"`
}

// InternalErrorResponse Response that indicates an internal error occurred
type InternalErrorResponse struct {
	// Message Details about the error that occurred
	Message *string `json:"message"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// InvoiceLineResponse Individual line item on the invoice
type InvoiceLineResponse struct {
	// Amount The amount of usage calculated for the service
	Amount *float64 `json:"amount,omitempty"`

	// Description Description of the service being billed for
	Description *string `json:"description"`

	// DisplayName The display name of the service
	DisplayName *string `json:"displayName"`

	// Metadata Metadata about the service provided. This could be anything, but it would be additional information worth
	// calling out about the service, like region, memory, or hard disks.
	Metadata *map[string]*string `json:"metadata"`

	// RegionId The region the service is in
	RegionId *string `json:"regionId"`

	// ServiceId The id of the service associated with the invoice line
	ServiceId   *int64       `json:"serviceId,omitempty"`
	ServiceType *ServiceType `json:"serviceType,omitempty"`

	// Tier The service tier. In the case of metal this would processor of the system.
	Tier *string `json:"tier"`

	// Total The total cost of the line item. This is the amount multiplied by the unit price.
	Total *float64 `json:"total,omitempty"`

	// UnitPrice The rate a which the service is billed at.
	UnitPrice *float64 `json:"unitPrice,omitempty"`
}

// InvoiceNotFound defines model for InvoiceNotFound.
type InvoiceNotFound struct {
	// Message Additional information about the response
	Message *string `json:"message"`

	// Success Flag indicating if the request was successful
	Success *bool `json:"success,omitempty"`
}

// InvoiceResponseRow defines model for InvoiceResponseRow.
type InvoiceResponseRow struct {
	// AccountId The account id the invoice applies to
	AccountId *int64 `json:"accountId,omitempty"`

	// DatePaid The date that the invoice was created in UTC time.
	DatePaid *time.Time `json:"datePaid"`

	// DueDate The due date for the invoice in UTC time.
	DueDate *time.Time `json:"dueDate"`

	// Id The unique identifier of the invoice
	Id *int64 `json:"id,omitempty"`

	// InvoiceDate The date that the invoice was paid in UTC time.
	InvoiceDate *time.Time `json:"invoiceDate"`

	// PayBefore The date to pay the invoice before in UTC time.
	PayBefore *time.Time `json:"payBefore,omitempty"`

	// Status The status of the invoice. One of: Draft, Sent, Paid, Void
	Status *string `json:"status"`

	// Total The total amount of the invoice
	Total *float64 `json:"total,omitempty"`
}

// ListInstanceNetworksResponse Response to the list instance networks endpoint
type ListInstanceNetworksResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]Details `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// ListInvoicesResponse defines model for ListInvoicesResponse.
type ListInvoicesResponse struct {
	// Message Additional information about the response
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]InvoiceResponseRow `json:"result"`

	// Success Flag indicating if the request was successful
	Success *bool `json:"success,omitempty"`
}

// ListMetadata For paginated responses, this object contains metadata about the list of items.
type ListMetadata struct {
	// Limit The max number of records to return in the response
	Limit *int32 `json:"limit,omitempty"`

	// Skip The number of records which were skipped as requested
	Skip *int64 `json:"skip,omitempty"`

	// TotalCount Total number of records in the collection
	TotalCount *int32 `json:"totalCount,omitempty"`
}

// ListUsageResponse Usage details for a specific year and month
type ListUsageResponse struct {
	Month *Month `json:"month,omitempty"`

	// Total The total cost of the usage for the month
	Total *float64 `json:"total,omitempty"`

	// Usages The usages for the services
	Usages *[]UsageResponseRow `json:"usages"`

	// Year The year for the usage
	Year *int32 `json:"year,omitempty"`
}

// ListUsageResponsePagedTswApiResponse Paged response to an API request
type ListUsageResponsePagedTswApiResponse struct {
	// Message Additional information about the response
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Usage details for a specific year and month
	Result *ListUsageResponse `json:"result,omitempty"`

	// Success Flag indicating if the request was successful
	Success *bool `json:"success,omitempty"`
}

// ListVolumesResponseRecord A single record of a volume from a request to list all volumes
type ListVolumesResponseRecord struct {
	// Attachments The attachments for the volume
	Attachments *[]VolumeAttachment `json:"attachments"`

	// CreatedAt The time the volume was created
	CreatedAt *string `json:"createdAt"`

	// Description The description of the volume
	Description *string `json:"description"`

	// DisplayName The name of the volume
	DisplayName *string `json:"displayName"`

	// Region The region where the volume is located
	Region *string `json:"region"`

	// Size The size of the volume
	Size *int32 `json:"size,omitempty"`

	// Status The current status of the volume
	Status *string `json:"status"`

	// UpdatedAt The time the volume was last updated
	UpdatedAt *string `json:"updatedAt"`

	// VolumeId The UUID of the volume
	VolumeId *string `json:"volumeId"`

	// VolumeType The type of the volume hdd or nvme
	VolumeType *string `json:"volumeType"`
}

// ListVolumesResponseRecordIEnumerableApiResponse Standard response object for all API requests with additional data
type ListVolumesResponseRecordIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]ListVolumesResponseRecord `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// LogMessage defines model for LogMessage.
type LogMessage struct {
	Message   *string    `json:"message"`
	Name      *string    `json:"name"`
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// LogMessageIEnumerableApiResponse Standard response object for all API requests with additional data
type LogMessageIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]LogMessage `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// MemoryModule defines model for MemoryModule.
type MemoryModule struct {
	CapacityGb        *int32  `json:"capacityGb,omitempty"`
	Manufacturer      *string `json:"manufacturer"`
	MemoryType        *string `json:"memoryType"`
	Name              *string `json:"name"`
	OperatingSpeedMhz *int32  `json:"operatingSpeedMhz,omitempty"`
	PartNumber        *string `json:"partNumber"`
	SerialNumber      *string `json:"serialNumber"`
	Status            *string `json:"status"`
}

// MemoryOption A memory option which is available on a tier.
type MemoryOption struct {
	// Default If this is the default memory option for the tier, this will be true.
	// False otherwise
	Default *bool `json:"default,omitempty"`

	// Gb The amount of memory in Gigabytes.
	Gb *int32 `json:"gb,omitempty"`

	// HourlyPrice The hourly price for the memory option.
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`

	// MonthlyPrice The monthly price for a memory option.
	MonthlyPrice *float64 `json:"monthlyPrice,omitempty"`
}

// MemoryPriceResponse Details about the price of a memory option
type MemoryPriceResponse struct {
	Amount *float64 `json:"amount,omitempty"`

	// HourlyPrice The hourly price for the memory option
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`

	// MonthlyPrice The monthly price for the memory option
	MonthlyPrice *float64 `json:"monthlyPrice,omitempty"`
	Unit         *string  `json:"unit"`
}

// MetalConfiguration defines model for MetalConfiguration.
type MetalConfiguration struct {
	Disks    *map[string]*string `json:"disks"`
	MemoryGb *int32              `json:"memoryGb,omitempty"`
	Quantity *int32              `json:"quantity,omitempty"`

	// Tier A metal tier represents the configuration options that have billable
	// implications for a metal service. This includes the CPU, memory, drive,
	// and network options.
	Tier *MetalTier `json:"tier,omitempty"`
}

// MetalConfigurationIEnumerableApiResponse Standard response object for all API requests with additional data
type MetalConfigurationIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]MetalConfiguration `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// MetalDevice defines model for MetalDevice.
type MetalDevice struct {
	BmcIp                 *string         `json:"bmcIp"`
	Children              *[]MetalDevice  `json:"children"`
	CpuModel              *string         `json:"cpuModel"`
	DeviceBay             *string         `json:"deviceBay"`
	DeviceType            *string         `json:"deviceType"`
	DeviceVendor          *DeviceVendor   `json:"deviceVendor,omitempty"`
	Id                    *int32          `json:"id,omitempty"`
	MemoryGb              *int32          `json:"memoryGb,omitempty"`
	MemoryModules         *[]MemoryModule `json:"memoryModules"`
	Name                  *string         `json:"name"`
	PowerStatus           *string         `json:"powerStatus"`
	PowerTheoreticalWatts *int32          `json:"powerTheoreticalWatts,omitempty"`
	RackFacilityId        *string         `json:"rackFacilityId"`
	RackId                *int32          `json:"rackId,omitempty"`
	RackName              *string         `json:"rackName"`
	RackPosition          *float64        `json:"rackPosition,omitempty"`
	RegionId              *string         `json:"regionId"`
	Serial                *string         `json:"serial"`

	// Service Represents a metal service.
	Service        *MetalService `json:"service,omitempty"`
	Status         *string       `json:"status"`
	StorageSummary *string       `json:"storageSummary"`
	TierId         *string       `json:"tierId"`
	UHeight        *int32        `json:"uHeight,omitempty"`
}

// MetalService Represents a metal service.
type MetalService struct {
	Account    *Account `json:"account,omitempty"`
	ActiveDate *string  `json:"activeDate"`
	BillingId  *string  `json:"billingId"`
	ContractId *int64   `json:"contractId"`
	Created    *string  `json:"created,omitempty"`

	// CurrentTask The current task being performed on the service.
	CurrentTask        *string `json:"currentTask"`
	Deleted            *string `json:"deleted"`
	DisplayName        *string `json:"displayName"`
	ExternalIdentifier *string `json:"externalIdentifier"`

	// HourlyPrice The current hourly price for the service
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`
	Id          *int64   `json:"id,omitempty"`

	// Image Details about the OS image applied to a service
	Image *Image `json:"image,omitempty"`

	// ImageId The ID of the OS image applied to the metal service
	ImageId    *string      `json:"imageId"`
	Interfaces *[]Interface `json:"interfaces"`

	// IpAddresses The ip addresses associated with the metal service
	IpAddresses        *[]string `json:"ipAddresses"`
	Ipv4DefaultGateway *string   `json:"ipv4DefaultGateway"`
	Ipv6DefaultGateway *string   `json:"ipv6DefaultGateway"`

	// MemoryGb The amount of memory on the metal service in GB
	MemoryGb    *int32       `json:"memoryGb,omitempty"`
	MetalDevice *MetalDevice `json:"metalDevice,omitempty"`

	// MonthlyPrice The current monthly price for the service
	MonthlyPrice *float64 `json:"monthlyPrice"`

	// ObjectType The object type of the service. Metal services are of type "MTL".
	ObjectType      *string `json:"objectType"`
	ParentServiceId *int64  `json:"parentServiceId"`

	// PowerState Power state of the device.
	PowerState         *string              `json:"powerState"`
	ProjectId          *int64               `json:"projectId,omitempty"`
	ProvisioningEvents *[]ProvisioningEvent `json:"provisioningEvents"`

	// RateId UID for the cost rate for this service as it's stored in the billing system
	RateId          *openapi_types.UUID            `json:"rateId"`
	Region          *Region                        `json:"region,omitempty"`
	RegionId        *string                        `json:"regionId"`
	ReservePricing  *bool                          `json:"reservePricing"`
	ServiceType     *string                        `json:"serviceType"`
	Sku             *string                        `json:"sku"`
	Status          *string                        `json:"status"`
	StorageDevices  *map[string]MetalStorageDevice `json:"storageDevices"`
	Tags            *[]string                      `json:"tags"`
	TerminationDate *string                        `json:"terminationDate"`

	// Tier A metal tier represents the configuration options that have billable
	// implications for a metal service. This includes the CPU, memory, drive,
	// and network options.
	Tier   *MetalTier `json:"tier,omitempty"`
	TierId *string    `json:"tierId"`
}

// MetalServiceApiResponse Standard response object for all API requests with additional data
type MetalServiceApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Represents a metal service.
	Result *MetalService `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// MetalServiceIEnumerableApiResponse Standard response object for all API requests with additional data
type MetalServiceIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]MetalService `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// MetalStorageDevice Describes a drive which can be installed in a drive slot.
type MetalStorageDevice struct {
	// CapacityGb The capacity of the drive in Gigabytes
	CapacityGb *int32 `json:"capacityGb,omitempty"`

	// HourlyPrice The hourly price for the specific drive configuration
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`

	// MonthlyPrice The monthly price for the specific drive
	MonthlyPrice *float64 `json:"monthlyPrice,omitempty"`

	// Name The *name* of the drive is a moniker that refers to the drives size. For
	// example this could be ```1.92t``` or ```960g```
	Name *string `json:"name"`

	// Type Describes the storage type of the drive. This could be HDD, SSD, or NVME.
	Type *StorageType `json:"type,omitempty"`
}

// MetalTemplate defines model for MetalTemplate.
type MetalTemplate struct {
	CloudInit *string `json:"cloudInit"`

	// CreateModel Request details for creating a metal service.
	CreateModel *CreateMetalRequest `json:"createModel,omitempty"`
	Created     *time.Time          `json:"created,omitempty"`
	Deleted     *time.Time          `json:"deleted"`
	DisplayName *string             `json:"displayName"`
	Id          *int64              `json:"id,omitempty"`
	ObjectType  *string             `json:"objectType"`
	ProjectId   *int64              `json:"projectId,omitempty"`
}

// MetalTemplateIEnumerableApiResponse Standard response object for all API requests with additional data
type MetalTemplateIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]MetalTemplate `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// MetalTier A metal tier represents the configuration options that have billable
// implications for a metal service. This includes the CPU, memory, drive,
// and network options.
type MetalTier struct {
	Availability *map[string]ServiceAvailability `json:"availability"`

	// Cpu The CPU model for the tier
	Cpu *string `json:"cpu"`

	// CpuDescription The description of the CPU in terms of cores and threads. For example,
	// 4c / 8t will denote a cpu with 4 cores and 8 threads.
	CpuDescription *string `json:"cpuDescription"`
	DriveSlotSetId *int32  `json:"driveSlotSetId,omitempty"`

	// DriveSlots Describes the available drive slots and drives which can be placed in a
	// metal configuration.
	DriveSlots         *[]DriveSlot `json:"driveSlots"`
	ExternalIdentifier *string      `json:"externalIdentifier"`
	Hidden             *bool        `json:"hidden,omitempty"`

	// HourlyPrice The hourly price for the tier
	HourlyPrice       *float64 `json:"hourlyPrice,omitempty"`
	Id                *string  `json:"id"`
	MemoryOptionSetId *int32   `json:"memoryOptionSetId,omitempty"`

	// MemoryOptions Describes the memory options available for the tier.
	MemoryOptions *[]MemoryOption `json:"memoryOptions"`

	// MonthlyPrice The monthly price for the tier
	MonthlyPrice       *float64 `json:"monthlyPrice,omitempty"`
	NetworkOptionSetId *int32   `json:"networkOptionSetId,omitempty"`

	// NetworkOptions The available network options for the tier. A network option defines
	// the speed of the network as well as the associated price.
	NetworkOptions *[]NetworkOption `json:"networkOptions"`
}

// MetalTierIEnumerableApiResponse Standard response object for all API requests with additional data
type MetalTierIEnumerableApiResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]MetalTier `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// Month defines model for Month.
type Month int32

// NetworkOption The available network options for the tier. A network option defines
// the speed of the network as well as the associated price.
type NetworkOption struct {
	// Default True if this is the default option for the tier
	Default *bool `json:"default,omitempty"`

	// HourlyPrice The hourly price for the network option
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`

	// MonthlyPrice The monthly price for the network option
	MonthlyPrice *float64 `json:"monthlyPrice,omitempty"`

	// SpeedGbps The speed of the network in Gbps
	SpeedGbps *int32 `json:"speedGbps,omitempty"`
}

// NetworkPriceResponse Details about the price of a network configuration
type NetworkPriceResponse struct {
	Amount *float64 `json:"amount,omitempty"`

	// HourlyPrice The hourly price for the network configuration
	HourlyPrice *float64 `json:"hourlyPrice,omitempty"`

	// MonthlyPrice The monthly price for the network configuration
	MonthlyPrice *float64 `json:"monthlyPrice,omitempty"`
	Unit         *string  `json:"unit"`
}

// NotFoundErrorResponse Response that indicates the requested resource was not found
type NotFoundErrorResponse struct {
	// Message Details about the resource that wasn't found
	Message *string `json:"message"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// Partition Describes a partition on a storage device
type Partition struct {
	// Device The device name of the partition.
	Device *string `json:"device"`

	// FileSystem The supported filesystems for metal services
	FileSystem *FileSystem `json:"fileSystem,omitempty"`

	// MountPoint The mount point for the partition.
	MountPoint *string `json:"mountPoint"`

	// Name Name of the partition.
	Name *string `json:"name"`

	// SizeBytes The size of the partition in bytes.  If not specified, the remainder of the space will be used.
	SizeBytes *int64 `json:"sizeBytes"`
}

// PowerCommand defines model for PowerCommand.
type PowerCommand int32

// PowerState Represents the power state of a service.
type PowerState int32

// ProvisioningEvent Represents a provisioning event in the system.
type ProvisioningEvent struct {
	// Body Gets or sets the body or description of the event.
	Body *string `json:"body"`

	// Priority Gets or sets the priority of the event.
	Priority *int32 `json:"priority,omitempty"`

	// State Represents the state of an event.
	State *EventState `json:"state,omitempty"`

	// Timestamp Gets or sets the timestamp when the event was created or updated.
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// RaidArray Describes a RAID array on a metal service.
type RaidArray struct {
	// FileSystem The supported filesystems for metal services
	FileSystem *FileSystem `json:"fileSystem,omitempty"`

	// Members The members of the RAID array.
	//
	// For example:
	//
	//     "members": [
	//         "sda-part1",
	//         "sdb-part1"
	//     ],
	Members *[]string `json:"members"`

	// MountPoint The mount point for the RAID array. **Must be set if partition is not set**
	MountPoint *string `json:"mountPoint"`

	// Name The name of the RAID array.
	Name *string `json:"name"`

	// Partitions Partitions can be created on raid arrays if the following options are not set: ```SizeBytes```,
	// ```FileSystem```, and ```MountPoint``
	Partitions *[]Partition `json:"partitions"`

	// SizeBytes The size of the RAID array in bytes. **Must be set if partition is not set**
	SizeBytes *int64 `json:"sizeBytes"`

	// Type The type of RAID array
	Type *RaidType `json:"type,omitempty"`
}

// RaidType The type of RAID array
type RaidType int32

// Region defines model for Region.
type Region struct {
	City         *string        `json:"city"`
	Country      *string        `json:"country"`
	Id           *string        `json:"id"`
	Location     *string        `json:"location"`
	Name         *string        `json:"name"`
	ServiceTypes *[]ServiceType `json:"serviceTypes"`
}

// ReinstallMetalRequest defines model for ReinstallMetalRequest.
type ReinstallMetalRequest struct {
	// Disks Dictionary of disk names and sizes in GB. If not specified, the default configuration for the metal tier will
	// be used.
	//
	// The key is the disk name and the value is the size in GB.  For example:
	//
	//     "disks": {
	//         "nvme0n1": "960g",
	//         "nvme1n1": "960g"
	//     }
	Disks *map[string]*string `json:"disks"`

	// DisplayName Display name for the service.
	DisplayName *string `json:"displayName"`

	// ImageId The image to use when creating this service.  Available images can be retrieved via the images endpoint.
	ImageId *string `json:"imageId"`

	// IpxeUrl If doing an iPXE boot, this is the URL to the script.
	IpxeUrl *string `json:"ipxeUrl"`

	// MemoryGb The amount of memory in GB to be allocated to the service.
	MemoryGb *int32 `json:"memoryGb,omitempty"`

	// Partitions Partitions to be created.  Not specifying this will result in a single root partition being created.
	//
	// Example for specifying partitions:
	//
	//     "partitions": [
	//         {
	//             "name": "nvme0n1-part1",
	//             "device": "nvme0n1",
	//             "sizeBytes": 50000000000
	//         },
	//         {
	//             "name": "nvme0n1-part1",
	//             "device": "nvme0n1",
	//             "sizeBytes": 50000000000
	//         },
	//         {
	//             "name": "nvme1n1-part2",
	//             "device": "nvme1n1"
	//             // If sizeBytes is not specified for a device, the remainder of the space will be used.
	//         }
	//     ]
	Partitions *[]Partition `json:"partitions"`

	// Password The password to be set for the root user.  If not provided, a random password will be generated.
	Password  *string `json:"password"`
	ProjectId *int64  `json:"projectId,omitempty"`

	// Quantity The number of services to be created.  By default, one will be created.
	Quantity *int32 `json:"quantity"`

	// RaidArrays Raid arrays to be created. Can reference physical device names or partitions from mediums of the same class.
	//
	// Example of specifying raid arrays:
	//
	//     "raidArrays": [
	//         {
	//             "name": "md0",
	//             "type": "Raid1",
	//             "members": [
	//                 "nvme0n1-part1",
	//                 "nvme1n1-part1"
	//             ],
	//             "fileSystem": "Ext4",
	//             "mountPoint": "/"
	//         }
	//     ]
	RaidArrays *[]RaidArray `json:"raidArrays"`

	// RegionId The region this service should be created in (for example: US-EAST-1).  If an invalid region is provided you will receive a 400 Bad Request.  Use the Regions endpoint to retrieve available regions.
	RegionId string `json:"regionId"`

	// ReservePricing Denotes if the metal service is being reserved for a whole year. If so, it gets the discounted rate
	ReservePricing *bool `json:"reservePricing,omitempty"`

	// Service Represents a metal service.
	Service   *MetalService `json:"service,omitempty"`
	ServiceId *int64        `json:"serviceId,omitempty"`
	// Deprecated:
	SshKeyId *int64 `json:"sshKeyId,omitempty"`

	// SshKeyIds The SSH key ids to be added to the service.  These keys will be added to the authorized_keys file for the root user.
	SshKeyIds *[]int64  `json:"sshKeyIds"`
	SshKeys   *[]SshKey `json:"sshKeys"`
	Tags      *[]string `json:"tags"`

	// TemplateId Template can be specified instead of image, partitions, sshKeyId, and userData.
	TemplateId *int64 `json:"templateId"`

	// TierId The service tier to be created.  For metal, this is typically the server config.  For example: 7302p-64g would create a Epyc 7302P system with 64G of ram.  Tier availability can be retrieved using the regions endpoints.
	TierId string `json:"tierId"`

	// TierObj A metal tier represents the configuration options that have billable
	// implications for a metal service. This includes the CPU, memory, drive,
	// and network options.
	TierObj *MetalTier `json:"tierObj,omitempty"`

	// UserData Additional user data
	UserData *string `json:"userData"`
}

// SearchResponse Result of a search request
type SearchResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Additional data returned by the API
	Result *[]SearchResponseRecord `json:"result"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// SearchResponseRecord Single record of a service for the search response
type SearchResponseRecord struct {
	// DisplayName The hostname of the instance
	DisplayName *string `json:"displayName"`

	// Id ID of the service
	Id *int64 `json:"id,omitempty"`

	// RegionId The region the service is in
	RegionId *string `json:"regionId"`

	// ServiceType Text of the service type Metal, Instance, etc...
	ServiceType *string `json:"serviceType"`

	// Status Text of the current status of the host
	Status *string `json:"status"`
}

// ServiceAvailability defines model for ServiceAvailability.
type ServiceAvailability struct {
	MaxQuantity *int32 `json:"maxQuantity,omitempty"`
}

// ServiceRenameRequest Describes a request to rename a service.
type ServiceRenameRequest struct {
	// Name The new name for the service
	Name *string `json:"name"`
}

// ServiceType defines model for ServiceType.
type ServiceType int32

// SshKey Represents an SSH key
type SshKey struct {
	Created *time.Time `json:"created,omitempty"`
	Deleted *time.Time `json:"deleted"`

	// DisplayName The display name of the SSH key
	DisplayName *string `json:"displayName"`
	Id          *int64  `json:"id,omitempty"`

	// Key The SSH key
	Key *string `json:"key"`

	// ObjectType The type of object
	ObjectType *string `json:"objectType"`

	// ProjectId The project ID
	ProjectId *int64 `json:"projectId,omitempty"`
}

// Status Describes the status of a service
type Status int32

// StorageType Describes the storage type of the drive. This could be HDD, SSD, or NVME.
type StorageType int32

// UpdateNetworkRequest Details about what to be updated about the network
type UpdateNetworkRequest struct {
	// DisplayName The display name of the network
	DisplayName *string `json:"displayName"`
}

// UpdateNetworkResponse Response to the update network endpoint
type UpdateNetworkResponse struct {
	// Message Provides additional detail about the response if one is required
	Message *string `json:"message"`

	// Metadata For paginated responses, this object contains metadata about the list of items.
	Metadata *ListMetadata `json:"metadata,omitempty"`

	// Result Details about the update to the network
	Result *UpdateNetworkResponseDetails `json:"result,omitempty"`

	// Success True if the request succeeded, false otherwise
	Success *bool `json:"success,omitempty"`
}

// UpdateNetworkResponseDetails Details about the update to the network
type UpdateNetworkResponseDetails struct {
	// DisplayName The display name of the network
	DisplayName *string `json:"displayName"`
}

// UsageResponseRow Usage for a service for a specific year and month.
type UsageResponseRow struct {
	// Amount The amount of usage that occurred during the month. Units are based on the service type.
	// For instance, for bare metal servers, this is the number of hours the service was
	// ```active```.
	Amount *float64 `json:"amount,omitempty"`

	// DisplayName The display name of the service as presented on the portal
	DisplayName *string `json:"displayName"`
	Month       *Month  `json:"month,omitempty"`

	// Rate The rate is the cost per unit of usage. For instance, for bare metal servers, this is the
	// hourly rate
	Rate *float64 `json:"rate,omitempty"`

	// RegionId The region that the service is located in (if applicable)
	RegionId *string `json:"regionId"`

	// ServiceId Id for the service
	ServiceId *int64 `json:"serviceId,omitempty"`

	// Total Total is the total cost of the usage for the month. This is calculated by multiplying the
	// amount of usage by the rate.
	Total *float64 `json:"total,omitempty"`

	// Year Year of the usage
	Year *int32 `json:"year,omitempty"`
}

// UsageResponseRowTswApiResponse Response to API Request
type UsageResponseRowTswApiResponse struct {
	// Message Additional information about the response
	Message *string `json:"message"`

	// Result Usage for a service for a specific year and month.
	Result *UsageResponseRow `json:"result,omitempty"`

	// Success Flag indicating if the request was successful
	Success *bool `json:"success,omitempty"`
}

// VolumeAttachment Contains details about the attachment of a volume to a server
type VolumeAttachment struct {
	// AttachedAt The time the volume was attached to the server
	AttachedAt *string `json:"attachedAt"`

	// AttachmentId The id for the specific attachment of the volume to the server
	AttachmentId *string `json:"attachmentId"`

	// Device The path of the device on the instance
	Device *string `json:"device"`
	Id     *string `json:"id"`

	// OpenstackServerId The id of the server the volume is attached to in Openstack
	OpenstackServerId *string `json:"openstackServerId"`

	// ServerId The TSW id of the server the volume is attached to
	ServerId *int64 `json:"serverId,omitempty"`

	// VolumeId The id of the volume in the attachment
	VolumeId *string `json:"volumeId"`
}

// GetV2InstanceParams defines parameters for GetV2Instance.
type GetV2InstanceParams struct {
	// Status Filter for services of a status (Optional) Available values are ```Active```, ```Pending```,
	// ```Suspended```, ```Terminated```
	Status *string `form:"Status,omitempty" json:"Status,omitempty"`

	// Region Filter for services in a region (Optional) May be comma separated to include multiple regions.
	// Available values can be retrieved from the Regions endpoint.
	Region *string `form:"Region,omitempty" json:"Region,omitempty"`

	// Tier Filter for services of a certain tier (Optional) May be comma separated to include multiple tiers.
	// Available values can be retrieved from the tiers endpoint.
	Tier *string `form:"Tier,omitempty" json:"Tier,omitempty"`

	// Tag Filter for services with a tag (Optional) May be comma separated to include multiple tags.
	// Available values can be retrieved from the tags endpoint.
	Tag *string `form:"Tag,omitempty" json:"Tag,omitempty"`

	// Limit The number of services to return (Optional: default 100)
	Limit *int32 `form:"Limit,omitempty" json:"Limit,omitempty"`

	// Skip The number of services to skip (Optional: default: 0)
	Skip *int32 `form:"Skip,omitempty" json:"Skip,omitempty"`

	// ProjectId The id of the project to filter services by
	ProjectId *int32 `form:"ProjectId,omitempty" json:"ProjectId,omitempty"`
}

// PostV2InstanceIdPowerCommandParams defines parameters for PostV2InstanceIdPowerCommand.
type PostV2InstanceIdPowerCommandParams struct {
	Command *PowerCommand `form:"command,omitempty" json:"command,omitempty"`
}

// GetV2InstanceInstanceIdNetworksParams defines parameters for GetV2InstanceInstanceIdNetworks.
type GetV2InstanceInstanceIdNetworksParams struct {
	// ProjectId The project id that the instance is under
	ProjectId *int64 `form:"ProjectId,omitempty" json:"ProjectId,omitempty"`

	// InstanceId The ID for the instance
	InstanceId *int64 `form:"InstanceId,omitempty" json:"InstanceId,omitempty"`

	// Limit *Optional* - filter to only return that many volume records. Max of 100.
	Limit *int32 `form:"Limit,omitempty" json:"Limit,omitempty"`

	// Skip *Optional* - filter to skip that many volume records to support paging.
	Skip *int32 `form:"Skip,omitempty" json:"Skip,omitempty"`
}

// PostV2InstanceInstanceIdNetworksAttachParams defines parameters for PostV2InstanceInstanceIdNetworksAttach.
type PostV2InstanceInstanceIdNetworksAttachParams struct {
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// PostV2InstanceInstanceIdNetworksDetachParams defines parameters for PostV2InstanceInstanceIdNetworksDetach.
type PostV2InstanceInstanceIdNetworksDetachParams struct {
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// GetV2InvoiceParams defines parameters for GetV2Invoice.
type GetV2InvoiceParams struct {
	// Skip The number of invoices to skip (for pagination)
	Skip *int32 `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The maximum number of invoices to return (for pagination)
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetV2MetalParams defines parameters for GetV2Metal.
type GetV2MetalParams struct {
	// Status Filter for services of a status (Optional) Available values are ```Active```, ```Pending```,
	// ```Suspended```, ```Terminated```
	Status *string `form:"Status,omitempty" json:"Status,omitempty"`

	// Region Filter for services in a region (Optional) May be comma separated to include multiple regions.
	// Available values can be retrieved from the Regions endpoint.
	Region *string `form:"Region,omitempty" json:"Region,omitempty"`

	// Tier Filter for services of a certain tier (Optional) May be comma separated to include multiple tiers.
	// Available values can be retrieved from the tiers endpoint.
	Tier *string `form:"Tier,omitempty" json:"Tier,omitempty"`

	// Tag Filter for services with a tag (Optional) May be comma separated to include multiple tags.
	// Available values can be retrieved from the tags endpoint.
	Tag *string `form:"Tag,omitempty" json:"Tag,omitempty"`

	// Limit The number of services to return (Optional: default 100)
	Limit *int32 `form:"Limit,omitempty" json:"Limit,omitempty"`

	// Skip The number of services to skip (Optional: default: 0)
	Skip *int32 `form:"Skip,omitempty" json:"Skip,omitempty"`

	// ProjectId The id of the project to filter services by
	ProjectId *int32 `form:"ProjectId,omitempty" json:"ProjectId,omitempty"`
}

// GetV2MetalAvailabilityParams defines parameters for GetV2MetalAvailability.
type GetV2MetalAvailabilityParams struct {
	// Region The region in which we're querying for availability
	Region *string `form:"Region,omitempty" json:"Region,omitempty"`

	// ProjectId The id of the project we're querying for
	ProjectId int64 `form:"ProjectId" json:"ProjectId"`
}

// PostV2MetalIdPowerCommandParams defines parameters for PostV2MetalIdPowerCommand.
type PostV2MetalIdPowerCommandParams struct {
	// Command The power command to send
	Command *PowerCommand `form:"command,omitempty" json:"command,omitempty"`
}

// DeleteV2NetworkParams defines parameters for DeleteV2Network.
type DeleteV2NetworkParams struct {
	// NetworkId The ID of the network to delete
	NetworkId *string `form:"networkId,omitempty" json:"networkId,omitempty"`
}

// GetV2NetworkParams defines parameters for GetV2Network.
type GetV2NetworkParams struct {
	// ProjectId The id for the project that the networks are in
	ProjectId int64 `form:"ProjectId" json:"ProjectId"`

	// RegionId *Optional* - Filter down the networks to a specific region. If more than one region is
	// desired, then provide the region ids in the form of a comma separated list. If you
	// would like to query across all regions, then leave this field blank.
	RegionId *string `form:"RegionId,omitempty" json:"RegionId,omitempty"`

	// Limit *Optional* - filter to only return that many volume records. Max of 100.
	Limit *int32 `form:"Limit,omitempty" json:"Limit,omitempty"`

	// Skip *Optional* - filter to skip that many volume records to support paging.
	Skip *int32 `form:"Skip,omitempty" json:"Skip,omitempty"`
}

// PostV2NetworkParams defines parameters for PostV2Network.
type PostV2NetworkParams struct {
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// PutV2NetworkParams defines parameters for PutV2Network.
type PutV2NetworkParams struct {
	// NetworkId The ID of the network to update
	NetworkId *string `form:"networkId,omitempty" json:"networkId,omitempty"`
}

// GetV2SearchParams defines parameters for GetV2Search.
type GetV2SearchParams struct {
	// Query The search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Skip The number of services to skip.
	Skip *int32 `form:"skip,omitempty" json:"skip,omitempty"`

	// Take The number of services to take.
	Take *int32 `form:"take,omitempty" json:"take,omitempty"`
}

// GetV2UsageParams defines parameters for GetV2Usage.
type GetV2UsageParams struct {
	// Year The year to list usages for.
	Year *int32 `form:"year,omitempty" json:"year,omitempty"`

	// Month The month to list usages for.
	Month *int32 `form:"month,omitempty" json:"month,omitempty"`

	// ProjectId The project ID to list usages for.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`

	// Skip The number of usages to skip.
	Skip *int32 `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of usages to take.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetV2UsageServiceIdParams defines parameters for GetV2UsageServiceId.
type GetV2UsageServiceIdParams struct {
	// Year The year to get usage for.
	Year *int32 `form:"year,omitempty" json:"year,omitempty"`

	// Month The month to get usage for.
	Month *int32 `form:"month,omitempty" json:"month,omitempty"`

	// ProjectId The project ID to get usage for.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// DeleteV2VolumeParams defines parameters for DeleteV2Volume.
type DeleteV2VolumeParams struct {
	// ProjectId The project ID to delete the volume in.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// GetV2VolumeParams defines parameters for GetV2Volume.
type GetV2VolumeParams struct {
	// ProjectId The project ID to list volumes for.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegionId The region ID to list volumes for. If not specified, volumes from all regions will be listed.
	RegionId *string `form:"regionId,omitempty" json:"regionId,omitempty"`

	// Limit The number of volumes to take. If not specified, all volumes will be listed.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Skip The number of volumes to skip. If not specified, no volumes will be skipped.
	Skip *int32 `form:"skip,omitempty" json:"skip,omitempty"`
}

// PostV2VolumeParams defines parameters for PostV2Volume.
type PostV2VolumeParams struct {
	// ProjectId The project ID to create the volume in.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// PutV2VolumeAttachParams defines parameters for PutV2VolumeAttach.
type PutV2VolumeAttachParams struct {
	// ProjectId The project ID to attach the volume in.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// PutV2VolumeDetachParams defines parameters for PutV2VolumeDetach.
type PutV2VolumeDetachParams struct {
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// PutV2VolumeExtendParams defines parameters for PutV2VolumeExtend.
type PutV2VolumeExtendParams struct {
	// ProjectId The project ID to extend the volume in.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// GetV2VolumeListAttachableParams defines parameters for GetV2VolumeListAttachable.
type GetV2VolumeListAttachableParams struct {
	// ProjectId The project ID to list attachable volumes for.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`

	// InstanceId The instance ID to list attachable volumes for.
	InstanceId *int64 `form:"instanceId,omitempty" json:"instanceId,omitempty"`

	// Limit The number of volumes to take. If not specified, all volumes will be listed.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Skip The number of volumes to skip. If not specified, no volumes will be skipped.
	Skip *int32 `form:"skip,omitempty" json:"skip,omitempty"`
}

// GetV2VolumeListAttachedParams defines parameters for GetV2VolumeListAttached.
type GetV2VolumeListAttachedParams struct {
	// ProjectId The project ID to list attached volumes for.
	ProjectId *int64 `form:"projectId,omitempty" json:"projectId,omitempty"`

	// InstanceId The instance ID to list attached volumes for.
	InstanceId *int64 `form:"instanceId,omitempty" json:"instanceId,omitempty"`
}

// PostV2InstanceApplicationWildcardPlusJSONRequestBody defines body for PostV2Instance for application/*+json ContentType.
type PostV2InstanceApplicationWildcardPlusJSONRequestBody = CreateInstanceRequest

// PostV2InstanceJSONRequestBody defines body for PostV2Instance for application/json ContentType.
type PostV2InstanceJSONRequestBody = CreateInstanceRequest

// PostV2InstanceApplicationJSONPatchPlusJSONRequestBody defines body for PostV2Instance for application/json-patch+json ContentType.
type PostV2InstanceApplicationJSONPatchPlusJSONRequestBody = CreateInstanceRequest

// PostV2InstanceInstanceIdNetworksAttachApplicationWildcardPlusJSONRequestBody defines body for PostV2InstanceInstanceIdNetworksAttach for application/*+json ContentType.
type PostV2InstanceInstanceIdNetworksAttachApplicationWildcardPlusJSONRequestBody = AttachToNetworkRequest

// PostV2InstanceInstanceIdNetworksAttachJSONRequestBody defines body for PostV2InstanceInstanceIdNetworksAttach for application/json ContentType.
type PostV2InstanceInstanceIdNetworksAttachJSONRequestBody = AttachToNetworkRequest

// PostV2InstanceInstanceIdNetworksAttachApplicationJSONPatchPlusJSONRequestBody defines body for PostV2InstanceInstanceIdNetworksAttach for application/json-patch+json ContentType.
type PostV2InstanceInstanceIdNetworksAttachApplicationJSONPatchPlusJSONRequestBody = AttachToNetworkRequest

// PostV2InstanceInstanceIdNetworksDetachApplicationWildcardPlusJSONRequestBody defines body for PostV2InstanceInstanceIdNetworksDetach for application/*+json ContentType.
type PostV2InstanceInstanceIdNetworksDetachApplicationWildcardPlusJSONRequestBody = DetachFromNetworkRequest

// PostV2InstanceInstanceIdNetworksDetachJSONRequestBody defines body for PostV2InstanceInstanceIdNetworksDetach for application/json ContentType.
type PostV2InstanceInstanceIdNetworksDetachJSONRequestBody = DetachFromNetworkRequest

// PostV2InstanceInstanceIdNetworksDetachApplicationJSONPatchPlusJSONRequestBody defines body for PostV2InstanceInstanceIdNetworksDetach for application/json-patch+json ContentType.
type PostV2InstanceInstanceIdNetworksDetachApplicationJSONPatchPlusJSONRequestBody = DetachFromNetworkRequest

// PostV2MetalApplicationWildcardPlusJSONRequestBody defines body for PostV2Metal for application/*+json ContentType.
type PostV2MetalApplicationWildcardPlusJSONRequestBody = CreateMetalRequest

// PostV2MetalJSONRequestBody defines body for PostV2Metal for application/json ContentType.
type PostV2MetalJSONRequestBody = CreateMetalRequest

// PostV2MetalApplicationJSONPatchPlusJSONRequestBody defines body for PostV2Metal for application/json-patch+json ContentType.
type PostV2MetalApplicationJSONPatchPlusJSONRequestBody = CreateMetalRequest

// PostV2MetalIdReinstallApplicationWildcardPlusJSONRequestBody defines body for PostV2MetalIdReinstall for application/*+json ContentType.
type PostV2MetalIdReinstallApplicationWildcardPlusJSONRequestBody = ReinstallMetalRequest

// PostV2MetalIdReinstallJSONRequestBody defines body for PostV2MetalIdReinstall for application/json ContentType.
type PostV2MetalIdReinstallJSONRequestBody = ReinstallMetalRequest

// PostV2MetalIdReinstallApplicationJSONPatchPlusJSONRequestBody defines body for PostV2MetalIdReinstall for application/json-patch+json ContentType.
type PostV2MetalIdReinstallApplicationJSONPatchPlusJSONRequestBody = ReinstallMetalRequest

// PostV2MetalIdRenameApplicationWildcardPlusJSONRequestBody defines body for PostV2MetalIdRename for application/*+json ContentType.
type PostV2MetalIdRenameApplicationWildcardPlusJSONRequestBody = ServiceRenameRequest

// PostV2MetalIdRenameJSONRequestBody defines body for PostV2MetalIdRename for application/json ContentType.
type PostV2MetalIdRenameJSONRequestBody = ServiceRenameRequest

// PostV2MetalIdRenameApplicationJSONPatchPlusJSONRequestBody defines body for PostV2MetalIdRename for application/json-patch+json ContentType.
type PostV2MetalIdRenameApplicationJSONPatchPlusJSONRequestBody = ServiceRenameRequest

// PostV2NetworkApplicationWildcardPlusJSONRequestBody defines body for PostV2Network for application/*+json ContentType.
type PostV2NetworkApplicationWildcardPlusJSONRequestBody = CreateNetworkRequest

// PostV2NetworkJSONRequestBody defines body for PostV2Network for application/json ContentType.
type PostV2NetworkJSONRequestBody = CreateNetworkRequest

// PostV2NetworkApplicationJSONPatchPlusJSONRequestBody defines body for PostV2Network for application/json-patch+json ContentType.
type PostV2NetworkApplicationJSONPatchPlusJSONRequestBody = CreateNetworkRequest

// PutV2NetworkApplicationWildcardPlusJSONRequestBody defines body for PutV2Network for application/*+json ContentType.
type PutV2NetworkApplicationWildcardPlusJSONRequestBody = UpdateNetworkRequest

// PutV2NetworkJSONRequestBody defines body for PutV2Network for application/json ContentType.
type PutV2NetworkJSONRequestBody = UpdateNetworkRequest

// PutV2NetworkApplicationJSONPatchPlusJSONRequestBody defines body for PutV2Network for application/json-patch+json ContentType.
type PutV2NetworkApplicationJSONPatchPlusJSONRequestBody = UpdateNetworkRequest

// PostV2PriceCalculateApplicationWildcardPlusJSONRequestBody defines body for PostV2PriceCalculate for application/*+json ContentType.
type PostV2PriceCalculateApplicationWildcardPlusJSONRequestBody = CalculatePriceRequest

// PostV2PriceCalculateJSONRequestBody defines body for PostV2PriceCalculate for application/json ContentType.
type PostV2PriceCalculateJSONRequestBody = CalculatePriceRequest

// PostV2PriceCalculateApplicationJSONPatchPlusJSONRequestBody defines body for PostV2PriceCalculate for application/json-patch+json ContentType.
type PostV2PriceCalculateApplicationJSONPatchPlusJSONRequestBody = CalculatePriceRequest

// DeleteV2VolumeApplicationWildcardPlusJSONRequestBody defines body for DeleteV2Volume for application/*+json ContentType.
type DeleteV2VolumeApplicationWildcardPlusJSONRequestBody = DeleteVolumeRequest

// DeleteV2VolumeJSONRequestBody defines body for DeleteV2Volume for application/json ContentType.
type DeleteV2VolumeJSONRequestBody = DeleteVolumeRequest

// DeleteV2VolumeApplicationJSONPatchPlusJSONRequestBody defines body for DeleteV2Volume for application/json-patch+json ContentType.
type DeleteV2VolumeApplicationJSONPatchPlusJSONRequestBody = DeleteVolumeRequest

// PostV2VolumeApplicationWildcardPlusJSONRequestBody defines body for PostV2Volume for application/*+json ContentType.
type PostV2VolumeApplicationWildcardPlusJSONRequestBody = CreateVolumeRequest

// PostV2VolumeJSONRequestBody defines body for PostV2Volume for application/json ContentType.
type PostV2VolumeJSONRequestBody = CreateVolumeRequest

// PostV2VolumeApplicationJSONPatchPlusJSONRequestBody defines body for PostV2Volume for application/json-patch+json ContentType.
type PostV2VolumeApplicationJSONPatchPlusJSONRequestBody = CreateVolumeRequest

// PutV2VolumeAttachApplicationWildcardPlusJSONRequestBody defines body for PutV2VolumeAttach for application/*+json ContentType.
type PutV2VolumeAttachApplicationWildcardPlusJSONRequestBody = AttachVolumeRequest

// PutV2VolumeAttachJSONRequestBody defines body for PutV2VolumeAttach for application/json ContentType.
type PutV2VolumeAttachJSONRequestBody = AttachVolumeRequest

// PutV2VolumeAttachApplicationJSONPatchPlusJSONRequestBody defines body for PutV2VolumeAttach for application/json-patch+json ContentType.
type PutV2VolumeAttachApplicationJSONPatchPlusJSONRequestBody = AttachVolumeRequest

// PutV2VolumeDetachApplicationWildcardPlusJSONRequestBody defines body for PutV2VolumeDetach for application/*+json ContentType.
type PutV2VolumeDetachApplicationWildcardPlusJSONRequestBody = DetachVolumeRequest

// PutV2VolumeDetachJSONRequestBody defines body for PutV2VolumeDetach for application/json ContentType.
type PutV2VolumeDetachJSONRequestBody = DetachVolumeRequest

// PutV2VolumeDetachApplicationJSONPatchPlusJSONRequestBody defines body for PutV2VolumeDetach for application/json-patch+json ContentType.
type PutV2VolumeDetachApplicationJSONPatchPlusJSONRequestBody = DetachVolumeRequest

// PutV2VolumeExtendApplicationWildcardPlusJSONRequestBody defines body for PutV2VolumeExtend for application/*+json ContentType.
type PutV2VolumeExtendApplicationWildcardPlusJSONRequestBody = ExtendVolumeRequest

// PutV2VolumeExtendJSONRequestBody defines body for PutV2VolumeExtend for application/json ContentType.
type PutV2VolumeExtendJSONRequestBody = ExtendVolumeRequest

// PutV2VolumeExtendApplicationJSONPatchPlusJSONRequestBody defines body for PutV2VolumeExtend for application/json-patch+json ContentType.
type PutV2VolumeExtendApplicationJSONPatchPlusJSONRequestBody = ExtendVolumeRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetV2Image request
	GetV2Image(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Instance request
	GetV2Instance(ctx context.Context, params *GetV2InstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2InstanceWithBody request with any body
	PostV2InstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostV2InstanceApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Instance(ctx context.Context, body PostV2InstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body PostV2InstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2InstanceTiers request
	GetV2InstanceTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteV2InstanceId request
	DeleteV2InstanceId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2InstanceId request
	GetV2InstanceId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2InstanceIdPowerCommand request
	PostV2InstanceIdPowerCommand(ctx context.Context, id int64, params *PostV2InstanceIdPowerCommandParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2InstanceInstanceIdNetworks request
	GetV2InstanceInstanceIdNetworks(ctx context.Context, instanceId string, params *GetV2InstanceInstanceIdNetworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2InstanceInstanceIdNetworksAttachWithBody request with any body
	PostV2InstanceInstanceIdNetworksAttachWithBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceInstanceIdNetworksAttachWithApplicationWildcardPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceInstanceIdNetworksAttach(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceInstanceIdNetworksAttachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2InstanceInstanceIdNetworksDetachWithBody request with any body
	PostV2InstanceInstanceIdNetworksDetachWithBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceInstanceIdNetworksDetachWithApplicationWildcardPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceInstanceIdNetworksDetach(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InstanceInstanceIdNetworksDetachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Invoice request
	GetV2Invoice(ctx context.Context, params *GetV2InvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2InvoiceInvoiceId request
	GetV2InvoiceInvoiceId(ctx context.Context, invoiceId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Metal request
	GetV2Metal(ctx context.Context, params *GetV2MetalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2MetalWithBody request with any body
	PostV2MetalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostV2MetalApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Metal(ctx context.Context, body PostV2MetalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body PostV2MetalApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2MetalAvailability request
	GetV2MetalAvailability(ctx context.Context, params *GetV2MetalAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2MetalTemplates request
	GetV2MetalTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2MetalTiers request
	GetV2MetalTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2MetalId request
	GetV2MetalId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2MetalIdLogs request
	GetV2MetalIdLogs(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2MetalIdPowerCommand request
	PostV2MetalIdPowerCommand(ctx context.Context, id int64, params *PostV2MetalIdPowerCommandParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2MetalIdReinstallWithBody request with any body
	PostV2MetalIdReinstallWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalIdReinstallWithApplicationWildcardPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalIdReinstall(ctx context.Context, id int64, body PostV2MetalIdReinstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalIdReinstallWithApplicationJSONPatchPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2MetalIdRenameWithBody request with any body
	PostV2MetalIdRenameWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalIdRenameWithApplicationWildcardPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalIdRename(ctx context.Context, id int64, body PostV2MetalIdRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2MetalIdRenameWithApplicationJSONPatchPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteV2Network request
	DeleteV2Network(ctx context.Context, params *DeleteV2NetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Network request
	GetV2Network(ctx context.Context, params *GetV2NetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2NetworkWithBody request with any body
	PostV2NetworkWithBody(ctx context.Context, params *PostV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2NetworkWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Network(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2NetworkWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV2NetworkWithBody request with any body
	PutV2NetworkWithBody(ctx context.Context, params *PutV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2NetworkWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2Network(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2NetworkWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2NetworkNetworkId request
	GetV2NetworkNetworkId(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2PriceCalculateWithBody request with any body
	PostV2PriceCalculateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2PriceCalculateWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostV2PriceCalculateApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2PriceCalculate(ctx context.Context, body PostV2PriceCalculateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2PriceCalculateWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body PostV2PriceCalculateApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Search request
	GetV2Search(ctx context.Context, params *GetV2SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Usage request
	GetV2Usage(ctx context.Context, params *GetV2UsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2UsageServiceId request
	GetV2UsageServiceId(ctx context.Context, serviceId int64, params *GetV2UsageServiceIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteV2VolumeWithBody request with any body
	DeleteV2VolumeWithBody(ctx context.Context, params *DeleteV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteV2VolumeWithApplicationWildcardPlusJSONBody(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteV2Volume(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteV2VolumeWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Volume request
	GetV2Volume(ctx context.Context, params *GetV2VolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2VolumeWithBody request with any body
	PostV2VolumeWithBody(ctx context.Context, params *PostV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2VolumeWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Volume(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2VolumeWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV2VolumeAttachWithBody request with any body
	PutV2VolumeAttachWithBody(ctx context.Context, params *PutV2VolumeAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeAttachWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeAttach(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeAttachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV2VolumeDetachWithBody request with any body
	PutV2VolumeDetachWithBody(ctx context.Context, params *PutV2VolumeDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeDetachWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeDetach(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeDetachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutV2VolumeExtendWithBody request with any body
	PutV2VolumeExtendWithBody(ctx context.Context, params *PutV2VolumeExtendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeExtendWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeExtend(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutV2VolumeExtendWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2VolumeListAttachable request
	GetV2VolumeListAttachable(ctx context.Context, params *GetV2VolumeListAttachableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2VolumeListAttached request
	GetV2VolumeListAttached(ctx context.Context, params *GetV2VolumeListAttachedParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetV2Image(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2ImageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Instance(ctx context.Context, params *GetV2InstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2InstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostV2InstanceApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Instance(ctx context.Context, body PostV2InstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body PostV2InstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2InstanceTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2InstanceTiersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2InstanceId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2InstanceIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2InstanceId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2InstanceIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceIdPowerCommand(ctx context.Context, id int64, params *PostV2InstanceIdPowerCommandParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceIdPowerCommandRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2InstanceInstanceIdNetworks(ctx context.Context, instanceId string, params *GetV2InstanceInstanceIdNetworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2InstanceInstanceIdNetworksRequest(c.Server, instanceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksAttachWithBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksAttachRequestWithBody(c.Server, instanceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksAttachWithApplicationWildcardPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksAttachRequestWithApplicationWildcardPlusJSONBody(c.Server, instanceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksAttach(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksAttachRequest(c.Server, instanceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksAttachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksAttachRequestWithApplicationJSONPatchPlusJSONBody(c.Server, instanceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksDetachWithBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksDetachRequestWithBody(c.Server, instanceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksDetachWithApplicationWildcardPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksDetachRequestWithApplicationWildcardPlusJSONBody(c.Server, instanceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksDetach(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksDetachRequest(c.Server, instanceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InstanceInstanceIdNetworksDetachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InstanceInstanceIdNetworksDetachRequestWithApplicationJSONPatchPlusJSONBody(c.Server, instanceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Invoice(ctx context.Context, params *GetV2InvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2InvoiceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2InvoiceInvoiceId(ctx context.Context, invoiceId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2InvoiceInvoiceIdRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Metal(ctx context.Context, params *GetV2MetalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2MetalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostV2MetalApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Metal(ctx context.Context, body PostV2MetalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body PostV2MetalApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2MetalAvailability(ctx context.Context, params *GetV2MetalAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2MetalAvailabilityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2MetalTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2MetalTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2MetalTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2MetalTiersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2MetalId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2MetalIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2MetalIdLogs(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2MetalIdLogsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdPowerCommand(ctx context.Context, id int64, params *PostV2MetalIdPowerCommandParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdPowerCommandRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdReinstallWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdReinstallRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdReinstallWithApplicationWildcardPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdReinstallRequestWithApplicationWildcardPlusJSONBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdReinstall(ctx context.Context, id int64, body PostV2MetalIdReinstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdReinstallRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdReinstallWithApplicationJSONPatchPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdReinstallRequestWithApplicationJSONPatchPlusJSONBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdRenameWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdRenameRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdRenameWithApplicationWildcardPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdRenameRequestWithApplicationWildcardPlusJSONBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdRename(ctx context.Context, id int64, body PostV2MetalIdRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdRenameRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2MetalIdRenameWithApplicationJSONPatchPlusJSONBody(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2MetalIdRenameRequestWithApplicationJSONPatchPlusJSONBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2Network(ctx context.Context, params *DeleteV2NetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2NetworkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Network(ctx context.Context, params *GetV2NetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2NetworkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2NetworkWithBody(ctx context.Context, params *PostV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2NetworkRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2NetworkWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2NetworkRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Network(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2NetworkRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2NetworkWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2NetworkRequestWithApplicationJSONPatchPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2NetworkWithBody(ctx context.Context, params *PutV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2NetworkRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2NetworkWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2NetworkRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2Network(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2NetworkRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2NetworkWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2NetworkRequestWithApplicationJSONPatchPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2NetworkNetworkId(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2NetworkNetworkIdRequest(c.Server, networkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2PriceCalculateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2PriceCalculateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2PriceCalculateWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostV2PriceCalculateApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2PriceCalculateRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2PriceCalculate(ctx context.Context, body PostV2PriceCalculateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2PriceCalculateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2PriceCalculateWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body PostV2PriceCalculateApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2PriceCalculateRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Search(ctx context.Context, params *GetV2SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2SearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Usage(ctx context.Context, params *GetV2UsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2UsageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2UsageServiceId(ctx context.Context, serviceId int64, params *GetV2UsageServiceIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2UsageServiceIdRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2VolumeWithBody(ctx context.Context, params *DeleteV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2VolumeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2VolumeWithApplicationWildcardPlusJSONBody(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2VolumeRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2Volume(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2VolumeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2VolumeWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2VolumeRequestWithApplicationJSONPatchPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Volume(ctx context.Context, params *GetV2VolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2VolumeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2VolumeWithBody(ctx context.Context, params *PostV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2VolumeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2VolumeWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2VolumeRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Volume(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2VolumeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2VolumeWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2VolumeRequestWithApplicationJSONPatchPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeAttachWithBody(ctx context.Context, params *PutV2VolumeAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeAttachRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeAttachWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeAttachRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeAttach(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeAttachRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeAttachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeAttachRequestWithApplicationJSONPatchPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeDetachWithBody(ctx context.Context, params *PutV2VolumeDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeDetachRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeDetachWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeDetachRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeDetach(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeDetachRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeDetachWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeDetachRequestWithApplicationJSONPatchPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeExtendWithBody(ctx context.Context, params *PutV2VolumeExtendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeExtendRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeExtendWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeExtendRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeExtend(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeExtendRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutV2VolumeExtendWithApplicationJSONPatchPlusJSONBody(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutV2VolumeExtendRequestWithApplicationJSONPatchPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2VolumeListAttachable(ctx context.Context, params *GetV2VolumeListAttachableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2VolumeListAttachableRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2VolumeListAttached(ctx context.Context, params *GetV2VolumeListAttachedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2VolumeListAttachedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetV2ImageRequest generates requests for GetV2Image
func NewGetV2ImageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2InstanceRequest generates requests for GetV2Instance
func NewGetV2InstanceRequest(server string, params *GetV2InstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Tier", runtime.ParamLocationQuery, *params.Tier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ProjectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2InstanceRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2Instance builder with application/*+json body
func NewPostV2InstanceRequestWithApplicationWildcardPlusJSONBody(server string, body PostV2InstanceApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceRequestWithBody(server, "application/*+json", bodyReader)
}

// NewPostV2InstanceRequest calls the generic PostV2Instance builder with application/json body
func NewPostV2InstanceRequest(server string, body PostV2InstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2InstanceRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2Instance builder with application/json-patch+json body
func NewPostV2InstanceRequestWithApplicationJSONPatchPlusJSONBody(server string, body PostV2InstanceApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewPostV2InstanceRequestWithBody generates requests for PostV2Instance with any type of body
func NewPostV2InstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2InstanceTiersRequest generates requests for GetV2InstanceTiers
func NewGetV2InstanceTiersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance/tiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteV2InstanceIdRequest generates requests for DeleteV2InstanceId
func NewDeleteV2InstanceIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2InstanceIdRequest generates requests for GetV2InstanceId
func NewGetV2InstanceIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2InstanceIdPowerCommandRequest generates requests for PostV2InstanceIdPowerCommand
func NewPostV2InstanceIdPowerCommandRequest(server string, id int64, params *PostV2InstanceIdPowerCommandParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance/%s/PowerCommand", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Command != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "command", runtime.ParamLocationQuery, *params.Command); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2InstanceInstanceIdNetworksRequest generates requests for GetV2InstanceInstanceIdNetworks
func NewGetV2InstanceInstanceIdNetworksRequest(server string, instanceId string, params *GetV2InstanceInstanceIdNetworksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance/%s/networks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ProjectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "InstanceId", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2InstanceInstanceIdNetworksAttachRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2InstanceInstanceIdNetworksAttach builder with application/*+json body
func NewPostV2InstanceInstanceIdNetworksAttachRequestWithApplicationWildcardPlusJSONBody(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceInstanceIdNetworksAttachRequestWithBody(server, instanceId, params, "application/*+json", bodyReader)
}

// NewPostV2InstanceInstanceIdNetworksAttachRequest calls the generic PostV2InstanceInstanceIdNetworksAttach builder with application/json body
func NewPostV2InstanceInstanceIdNetworksAttachRequest(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceInstanceIdNetworksAttachRequestWithBody(server, instanceId, params, "application/json", bodyReader)
}

// NewPostV2InstanceInstanceIdNetworksAttachRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2InstanceInstanceIdNetworksAttach builder with application/json-patch+json body
func NewPostV2InstanceInstanceIdNetworksAttachRequestWithApplicationJSONPatchPlusJSONBody(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceInstanceIdNetworksAttachRequestWithBody(server, instanceId, params, "application/json-patch+json", bodyReader)
}

// NewPostV2InstanceInstanceIdNetworksAttachRequestWithBody generates requests for PostV2InstanceInstanceIdNetworksAttach with any type of body
func NewPostV2InstanceInstanceIdNetworksAttachRequestWithBody(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance/%s/networks/attach", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2InstanceInstanceIdNetworksDetachRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2InstanceInstanceIdNetworksDetach builder with application/*+json body
func NewPostV2InstanceInstanceIdNetworksDetachRequestWithApplicationWildcardPlusJSONBody(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceInstanceIdNetworksDetachRequestWithBody(server, instanceId, params, "application/*+json", bodyReader)
}

// NewPostV2InstanceInstanceIdNetworksDetachRequest calls the generic PostV2InstanceInstanceIdNetworksDetach builder with application/json body
func NewPostV2InstanceInstanceIdNetworksDetachRequest(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceInstanceIdNetworksDetachRequestWithBody(server, instanceId, params, "application/json", bodyReader)
}

// NewPostV2InstanceInstanceIdNetworksDetachRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2InstanceInstanceIdNetworksDetach builder with application/json-patch+json body
func NewPostV2InstanceInstanceIdNetworksDetachRequestWithApplicationJSONPatchPlusJSONBody(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InstanceInstanceIdNetworksDetachRequestWithBody(server, instanceId, params, "application/json-patch+json", bodyReader)
}

// NewPostV2InstanceInstanceIdNetworksDetachRequestWithBody generates requests for PostV2InstanceInstanceIdNetworksDetach with any type of body
func NewPostV2InstanceInstanceIdNetworksDetachRequestWithBody(server string, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Instance/%s/networks/detach", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2InvoiceRequest generates requests for GetV2Invoice
func NewGetV2InvoiceRequest(server string, params *GetV2InvoiceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Invoice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2InvoiceInvoiceIdRequest generates requests for GetV2InvoiceInvoiceId
func NewGetV2InvoiceInvoiceIdRequest(server string, invoiceId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Invoice/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2MetalRequest generates requests for GetV2Metal
func NewGetV2MetalRequest(server string, params *GetV2MetalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Tier", runtime.ParamLocationQuery, *params.Tier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ProjectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2MetalRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2Metal builder with application/*+json body
func NewPostV2MetalRequestWithApplicationWildcardPlusJSONBody(server string, body PostV2MetalApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalRequestWithBody(server, "application/*+json", bodyReader)
}

// NewPostV2MetalRequest calls the generic PostV2Metal builder with application/json body
func NewPostV2MetalRequest(server string, body PostV2MetalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2MetalRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2Metal builder with application/json-patch+json body
func NewPostV2MetalRequestWithApplicationJSONPatchPlusJSONBody(server string, body PostV2MetalApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewPostV2MetalRequestWithBody generates requests for PostV2Metal with any type of body
func NewPostV2MetalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2MetalAvailabilityRequest generates requests for GetV2MetalAvailability
func NewGetV2MetalAvailabilityRequest(server string, params *GetV2MetalAvailabilityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/Availability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ProjectId", runtime.ParamLocationQuery, params.ProjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2MetalTemplatesRequest generates requests for GetV2MetalTemplates
func NewGetV2MetalTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2MetalTiersRequest generates requests for GetV2MetalTiers
func NewGetV2MetalTiersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/tiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2MetalIdRequest generates requests for GetV2MetalId
func NewGetV2MetalIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2MetalIdLogsRequest generates requests for GetV2MetalIdLogs
func NewGetV2MetalIdLogsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/%s/Logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2MetalIdPowerCommandRequest generates requests for PostV2MetalIdPowerCommand
func NewPostV2MetalIdPowerCommandRequest(server string, id int64, params *PostV2MetalIdPowerCommandParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/%s/PowerCommand", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Command != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "command", runtime.ParamLocationQuery, *params.Command); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2MetalIdReinstallRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2MetalIdReinstall builder with application/*+json body
func NewPostV2MetalIdReinstallRequestWithApplicationWildcardPlusJSONBody(server string, id int64, body PostV2MetalIdReinstallApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalIdReinstallRequestWithBody(server, id, "application/*+json", bodyReader)
}

// NewPostV2MetalIdReinstallRequest calls the generic PostV2MetalIdReinstall builder with application/json body
func NewPostV2MetalIdReinstallRequest(server string, id int64, body PostV2MetalIdReinstallJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalIdReinstallRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostV2MetalIdReinstallRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2MetalIdReinstall builder with application/json-patch+json body
func NewPostV2MetalIdReinstallRequestWithApplicationJSONPatchPlusJSONBody(server string, id int64, body PostV2MetalIdReinstallApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalIdReinstallRequestWithBody(server, id, "application/json-patch+json", bodyReader)
}

// NewPostV2MetalIdReinstallRequestWithBody generates requests for PostV2MetalIdReinstall with any type of body
func NewPostV2MetalIdReinstallRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/%s/Reinstall", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2MetalIdRenameRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2MetalIdRename builder with application/*+json body
func NewPostV2MetalIdRenameRequestWithApplicationWildcardPlusJSONBody(server string, id int64, body PostV2MetalIdRenameApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalIdRenameRequestWithBody(server, id, "application/*+json", bodyReader)
}

// NewPostV2MetalIdRenameRequest calls the generic PostV2MetalIdRename builder with application/json body
func NewPostV2MetalIdRenameRequest(server string, id int64, body PostV2MetalIdRenameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalIdRenameRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostV2MetalIdRenameRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2MetalIdRename builder with application/json-patch+json body
func NewPostV2MetalIdRenameRequestWithApplicationJSONPatchPlusJSONBody(server string, id int64, body PostV2MetalIdRenameApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2MetalIdRenameRequestWithBody(server, id, "application/json-patch+json", bodyReader)
}

// NewPostV2MetalIdRenameRequestWithBody generates requests for PostV2MetalIdRename with any type of body
func NewPostV2MetalIdRenameRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Metal/%s/rename", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteV2NetworkRequest generates requests for DeleteV2Network
func NewDeleteV2NetworkRequest(server string, params *DeleteV2NetworkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Network")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NetworkId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "networkId", runtime.ParamLocationQuery, *params.NetworkId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2NetworkRequest generates requests for GetV2Network
func NewGetV2NetworkRequest(server string, params *GetV2NetworkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Network")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ProjectId", runtime.ParamLocationQuery, params.ProjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "RegionId", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2NetworkRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2Network builder with application/*+json body
func NewPostV2NetworkRequestWithApplicationWildcardPlusJSONBody(server string, params *PostV2NetworkParams, body PostV2NetworkApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2NetworkRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewPostV2NetworkRequest calls the generic PostV2Network builder with application/json body
func NewPostV2NetworkRequest(server string, params *PostV2NetworkParams, body PostV2NetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2NetworkRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV2NetworkRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2Network builder with application/json-patch+json body
func NewPostV2NetworkRequestWithApplicationJSONPatchPlusJSONBody(server string, params *PostV2NetworkParams, body PostV2NetworkApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2NetworkRequestWithBody(server, params, "application/json-patch+json", bodyReader)
}

// NewPostV2NetworkRequestWithBody generates requests for PostV2Network with any type of body
func NewPostV2NetworkRequestWithBody(server string, params *PostV2NetworkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Network")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV2NetworkRequestWithApplicationWildcardPlusJSONBody calls the generic PutV2Network builder with application/*+json body
func NewPutV2NetworkRequestWithApplicationWildcardPlusJSONBody(server string, params *PutV2NetworkParams, body PutV2NetworkApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2NetworkRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewPutV2NetworkRequest calls the generic PutV2Network builder with application/json body
func NewPutV2NetworkRequest(server string, params *PutV2NetworkParams, body PutV2NetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2NetworkRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPutV2NetworkRequestWithApplicationJSONPatchPlusJSONBody calls the generic PutV2Network builder with application/json-patch+json body
func NewPutV2NetworkRequestWithApplicationJSONPatchPlusJSONBody(server string, params *PutV2NetworkParams, body PutV2NetworkApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2NetworkRequestWithBody(server, params, "application/json-patch+json", bodyReader)
}

// NewPutV2NetworkRequestWithBody generates requests for PutV2Network with any type of body
func NewPutV2NetworkRequestWithBody(server string, params *PutV2NetworkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Network")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NetworkId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "networkId", runtime.ParamLocationQuery, *params.NetworkId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2NetworkNetworkIdRequest generates requests for GetV2NetworkNetworkId
func NewGetV2NetworkNetworkIdRequest(server string, networkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Network/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2PriceCalculateRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2PriceCalculate builder with application/*+json body
func NewPostV2PriceCalculateRequestWithApplicationWildcardPlusJSONBody(server string, body PostV2PriceCalculateApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2PriceCalculateRequestWithBody(server, "application/*+json", bodyReader)
}

// NewPostV2PriceCalculateRequest calls the generic PostV2PriceCalculate builder with application/json body
func NewPostV2PriceCalculateRequest(server string, body PostV2PriceCalculateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2PriceCalculateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2PriceCalculateRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2PriceCalculate builder with application/json-patch+json body
func NewPostV2PriceCalculateRequestWithApplicationJSONPatchPlusJSONBody(server string, body PostV2PriceCalculateApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2PriceCalculateRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewPostV2PriceCalculateRequestWithBody generates requests for PostV2PriceCalculate with any type of body
func NewPostV2PriceCalculateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Price/Calculate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2SearchRequest generates requests for GetV2Search
func NewGetV2SearchRequest(server string, params *GetV2SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Take != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "take", runtime.ParamLocationQuery, *params.Take); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2UsageRequest generates requests for GetV2Usage
func NewGetV2UsageRequest(server string, params *GetV2UsageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Month != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "month", runtime.ParamLocationQuery, *params.Month); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2UsageServiceIdRequest generates requests for GetV2UsageServiceId
func NewGetV2UsageServiceIdRequest(server string, serviceId int64, params *GetV2UsageServiceIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Usage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Month != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "month", runtime.ParamLocationQuery, *params.Month); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteV2VolumeRequestWithApplicationWildcardPlusJSONBody calls the generic DeleteV2Volume builder with application/*+json body
func NewDeleteV2VolumeRequestWithApplicationWildcardPlusJSONBody(server string, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteV2VolumeRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewDeleteV2VolumeRequest calls the generic DeleteV2Volume builder with application/json body
func NewDeleteV2VolumeRequest(server string, params *DeleteV2VolumeParams, body DeleteV2VolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteV2VolumeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteV2VolumeRequestWithApplicationJSONPatchPlusJSONBody calls the generic DeleteV2Volume builder with application/json-patch+json body
func NewDeleteV2VolumeRequestWithApplicationJSONPatchPlusJSONBody(server string, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteV2VolumeRequestWithBody(server, params, "application/json-patch+json", bodyReader)
}

// NewDeleteV2VolumeRequestWithBody generates requests for DeleteV2Volume with any type of body
func NewDeleteV2VolumeRequestWithBody(server string, params *DeleteV2VolumeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2VolumeRequest generates requests for GetV2Volume
func NewGetV2VolumeRequest(server string, params *GetV2VolumeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regionId", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2VolumeRequestWithApplicationWildcardPlusJSONBody calls the generic PostV2Volume builder with application/*+json body
func NewPostV2VolumeRequestWithApplicationWildcardPlusJSONBody(server string, params *PostV2VolumeParams, body PostV2VolumeApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2VolumeRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewPostV2VolumeRequest calls the generic PostV2Volume builder with application/json body
func NewPostV2VolumeRequest(server string, params *PostV2VolumeParams, body PostV2VolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2VolumeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV2VolumeRequestWithApplicationJSONPatchPlusJSONBody calls the generic PostV2Volume builder with application/json-patch+json body
func NewPostV2VolumeRequestWithApplicationJSONPatchPlusJSONBody(server string, params *PostV2VolumeParams, body PostV2VolumeApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2VolumeRequestWithBody(server, params, "application/json-patch+json", bodyReader)
}

// NewPostV2VolumeRequestWithBody generates requests for PostV2Volume with any type of body
func NewPostV2VolumeRequestWithBody(server string, params *PostV2VolumeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV2VolumeAttachRequestWithApplicationWildcardPlusJSONBody calls the generic PutV2VolumeAttach builder with application/*+json body
func NewPutV2VolumeAttachRequestWithApplicationWildcardPlusJSONBody(server string, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeAttachRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewPutV2VolumeAttachRequest calls the generic PutV2VolumeAttach builder with application/json body
func NewPutV2VolumeAttachRequest(server string, params *PutV2VolumeAttachParams, body PutV2VolumeAttachJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeAttachRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPutV2VolumeAttachRequestWithApplicationJSONPatchPlusJSONBody calls the generic PutV2VolumeAttach builder with application/json-patch+json body
func NewPutV2VolumeAttachRequestWithApplicationJSONPatchPlusJSONBody(server string, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeAttachRequestWithBody(server, params, "application/json-patch+json", bodyReader)
}

// NewPutV2VolumeAttachRequestWithBody generates requests for PutV2VolumeAttach with any type of body
func NewPutV2VolumeAttachRequestWithBody(server string, params *PutV2VolumeAttachParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume/attach")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV2VolumeDetachRequestWithApplicationWildcardPlusJSONBody calls the generic PutV2VolumeDetach builder with application/*+json body
func NewPutV2VolumeDetachRequestWithApplicationWildcardPlusJSONBody(server string, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeDetachRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewPutV2VolumeDetachRequest calls the generic PutV2VolumeDetach builder with application/json body
func NewPutV2VolumeDetachRequest(server string, params *PutV2VolumeDetachParams, body PutV2VolumeDetachJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeDetachRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPutV2VolumeDetachRequestWithApplicationJSONPatchPlusJSONBody calls the generic PutV2VolumeDetach builder with application/json-patch+json body
func NewPutV2VolumeDetachRequestWithApplicationJSONPatchPlusJSONBody(server string, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeDetachRequestWithBody(server, params, "application/json-patch+json", bodyReader)
}

// NewPutV2VolumeDetachRequestWithBody generates requests for PutV2VolumeDetach with any type of body
func NewPutV2VolumeDetachRequestWithBody(server string, params *PutV2VolumeDetachParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume/detach")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutV2VolumeExtendRequestWithApplicationWildcardPlusJSONBody calls the generic PutV2VolumeExtend builder with application/*+json body
func NewPutV2VolumeExtendRequestWithApplicationWildcardPlusJSONBody(server string, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeExtendRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewPutV2VolumeExtendRequest calls the generic PutV2VolumeExtend builder with application/json body
func NewPutV2VolumeExtendRequest(server string, params *PutV2VolumeExtendParams, body PutV2VolumeExtendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeExtendRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPutV2VolumeExtendRequestWithApplicationJSONPatchPlusJSONBody calls the generic PutV2VolumeExtend builder with application/json-patch+json body
func NewPutV2VolumeExtendRequestWithApplicationJSONPatchPlusJSONBody(server string, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutV2VolumeExtendRequestWithBody(server, params, "application/json-patch+json", bodyReader)
}

// NewPutV2VolumeExtendRequestWithBody generates requests for PutV2VolumeExtend with any type of body
func NewPutV2VolumeExtendRequestWithBody(server string, params *PutV2VolumeExtendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume/extend")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2VolumeListAttachableRequest generates requests for GetV2VolumeListAttachable
func NewGetV2VolumeListAttachableRequest(server string, params *GetV2VolumeListAttachableParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume/list-attachable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instanceId", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2VolumeListAttachedRequest generates requests for GetV2VolumeListAttached
func NewGetV2VolumeListAttachedRequest(server string, params *GetV2VolumeListAttachedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/Volume/list-attached")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instanceId", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetV2ImageWithResponse request
	GetV2ImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2ImageResponse, error)

	// GetV2InstanceWithResponse request
	GetV2InstanceWithResponse(ctx context.Context, params *GetV2InstanceParams, reqEditors ...RequestEditorFn) (*GetV2InstanceResponse, error)

	// PostV2InstanceWithBodyWithResponse request with any body
	PostV2InstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error)

	PostV2InstanceWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostV2InstanceApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error)

	PostV2InstanceWithResponse(ctx context.Context, body PostV2InstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error)

	PostV2InstanceWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, body PostV2InstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error)

	// GetV2InstanceTiersWithResponse request
	GetV2InstanceTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2InstanceTiersResponse, error)

	// DeleteV2InstanceIdWithResponse request
	DeleteV2InstanceIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteV2InstanceIdResponse, error)

	// GetV2InstanceIdWithResponse request
	GetV2InstanceIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetV2InstanceIdResponse, error)

	// PostV2InstanceIdPowerCommandWithResponse request
	PostV2InstanceIdPowerCommandWithResponse(ctx context.Context, id int64, params *PostV2InstanceIdPowerCommandParams, reqEditors ...RequestEditorFn) (*PostV2InstanceIdPowerCommandResponse, error)

	// GetV2InstanceInstanceIdNetworksWithResponse request
	GetV2InstanceInstanceIdNetworksWithResponse(ctx context.Context, instanceId string, params *GetV2InstanceInstanceIdNetworksParams, reqEditors ...RequestEditorFn) (*GetV2InstanceInstanceIdNetworksResponse, error)

	// PostV2InstanceInstanceIdNetworksAttachWithBodyWithResponse request with any body
	PostV2InstanceInstanceIdNetworksAttachWithBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error)

	PostV2InstanceInstanceIdNetworksAttachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error)

	PostV2InstanceInstanceIdNetworksAttachWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error)

	PostV2InstanceInstanceIdNetworksAttachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error)

	// PostV2InstanceInstanceIdNetworksDetachWithBodyWithResponse request with any body
	PostV2InstanceInstanceIdNetworksDetachWithBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error)

	PostV2InstanceInstanceIdNetworksDetachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error)

	PostV2InstanceInstanceIdNetworksDetachWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error)

	PostV2InstanceInstanceIdNetworksDetachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error)

	// GetV2InvoiceWithResponse request
	GetV2InvoiceWithResponse(ctx context.Context, params *GetV2InvoiceParams, reqEditors ...RequestEditorFn) (*GetV2InvoiceResponse, error)

	// GetV2InvoiceInvoiceIdWithResponse request
	GetV2InvoiceInvoiceIdWithResponse(ctx context.Context, invoiceId int64, reqEditors ...RequestEditorFn) (*GetV2InvoiceInvoiceIdResponse, error)

	// GetV2MetalWithResponse request
	GetV2MetalWithResponse(ctx context.Context, params *GetV2MetalParams, reqEditors ...RequestEditorFn) (*GetV2MetalResponse, error)

	// PostV2MetalWithBodyWithResponse request with any body
	PostV2MetalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error)

	PostV2MetalWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostV2MetalApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error)

	PostV2MetalWithResponse(ctx context.Context, body PostV2MetalJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error)

	PostV2MetalWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, body PostV2MetalApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error)

	// GetV2MetalAvailabilityWithResponse request
	GetV2MetalAvailabilityWithResponse(ctx context.Context, params *GetV2MetalAvailabilityParams, reqEditors ...RequestEditorFn) (*GetV2MetalAvailabilityResponse, error)

	// GetV2MetalTemplatesWithResponse request
	GetV2MetalTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2MetalTemplatesResponse, error)

	// GetV2MetalTiersWithResponse request
	GetV2MetalTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2MetalTiersResponse, error)

	// GetV2MetalIdWithResponse request
	GetV2MetalIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetV2MetalIdResponse, error)

	// GetV2MetalIdLogsWithResponse request
	GetV2MetalIdLogsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetV2MetalIdLogsResponse, error)

	// PostV2MetalIdPowerCommandWithResponse request
	PostV2MetalIdPowerCommandWithResponse(ctx context.Context, id int64, params *PostV2MetalIdPowerCommandParams, reqEditors ...RequestEditorFn) (*PostV2MetalIdPowerCommandResponse, error)

	// PostV2MetalIdReinstallWithBodyWithResponse request with any body
	PostV2MetalIdReinstallWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error)

	PostV2MetalIdReinstallWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error)

	PostV2MetalIdReinstallWithResponse(ctx context.Context, id int64, body PostV2MetalIdReinstallJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error)

	PostV2MetalIdReinstallWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error)

	// PostV2MetalIdRenameWithBodyWithResponse request with any body
	PostV2MetalIdRenameWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error)

	PostV2MetalIdRenameWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error)

	PostV2MetalIdRenameWithResponse(ctx context.Context, id int64, body PostV2MetalIdRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error)

	PostV2MetalIdRenameWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error)

	// DeleteV2NetworkWithResponse request
	DeleteV2NetworkWithResponse(ctx context.Context, params *DeleteV2NetworkParams, reqEditors ...RequestEditorFn) (*DeleteV2NetworkResponse, error)

	// GetV2NetworkWithResponse request
	GetV2NetworkWithResponse(ctx context.Context, params *GetV2NetworkParams, reqEditors ...RequestEditorFn) (*GetV2NetworkResponse, error)

	// PostV2NetworkWithBodyWithResponse request with any body
	PostV2NetworkWithBodyWithResponse(ctx context.Context, params *PostV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error)

	PostV2NetworkWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error)

	PostV2NetworkWithResponse(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error)

	PostV2NetworkWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error)

	// PutV2NetworkWithBodyWithResponse request with any body
	PutV2NetworkWithBodyWithResponse(ctx context.Context, params *PutV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error)

	PutV2NetworkWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error)

	PutV2NetworkWithResponse(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error)

	PutV2NetworkWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error)

	// GetV2NetworkNetworkIdWithResponse request
	GetV2NetworkNetworkIdWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*GetV2NetworkNetworkIdResponse, error)

	// PostV2PriceCalculateWithBodyWithResponse request with any body
	PostV2PriceCalculateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error)

	PostV2PriceCalculateWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostV2PriceCalculateApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error)

	PostV2PriceCalculateWithResponse(ctx context.Context, body PostV2PriceCalculateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error)

	PostV2PriceCalculateWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, body PostV2PriceCalculateApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error)

	// GetV2SearchWithResponse request
	GetV2SearchWithResponse(ctx context.Context, params *GetV2SearchParams, reqEditors ...RequestEditorFn) (*GetV2SearchResponse, error)

	// GetV2UsageWithResponse request
	GetV2UsageWithResponse(ctx context.Context, params *GetV2UsageParams, reqEditors ...RequestEditorFn) (*GetV2UsageResponse, error)

	// GetV2UsageServiceIdWithResponse request
	GetV2UsageServiceIdWithResponse(ctx context.Context, serviceId int64, params *GetV2UsageServiceIdParams, reqEditors ...RequestEditorFn) (*GetV2UsageServiceIdResponse, error)

	// DeleteV2VolumeWithBodyWithResponse request with any body
	DeleteV2VolumeWithBodyWithResponse(ctx context.Context, params *DeleteV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error)

	DeleteV2VolumeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error)

	DeleteV2VolumeWithResponse(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error)

	DeleteV2VolumeWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error)

	// GetV2VolumeWithResponse request
	GetV2VolumeWithResponse(ctx context.Context, params *GetV2VolumeParams, reqEditors ...RequestEditorFn) (*GetV2VolumeResponse, error)

	// PostV2VolumeWithBodyWithResponse request with any body
	PostV2VolumeWithBodyWithResponse(ctx context.Context, params *PostV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error)

	PostV2VolumeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error)

	PostV2VolumeWithResponse(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error)

	PostV2VolumeWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error)

	// PutV2VolumeAttachWithBodyWithResponse request with any body
	PutV2VolumeAttachWithBodyWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error)

	PutV2VolumeAttachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error)

	PutV2VolumeAttachWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error)

	PutV2VolumeAttachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error)

	// PutV2VolumeDetachWithBodyWithResponse request with any body
	PutV2VolumeDetachWithBodyWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error)

	PutV2VolumeDetachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error)

	PutV2VolumeDetachWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error)

	PutV2VolumeDetachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error)

	// PutV2VolumeExtendWithBodyWithResponse request with any body
	PutV2VolumeExtendWithBodyWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error)

	PutV2VolumeExtendWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error)

	PutV2VolumeExtendWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error)

	PutV2VolumeExtendWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error)

	// GetV2VolumeListAttachableWithResponse request
	GetV2VolumeListAttachableWithResponse(ctx context.Context, params *GetV2VolumeListAttachableParams, reqEditors ...RequestEditorFn) (*GetV2VolumeListAttachableResponse, error)

	// GetV2VolumeListAttachedWithResponse request
	GetV2VolumeListAttachedWithResponse(ctx context.Context, params *GetV2VolumeListAttachedParams, reqEditors ...RequestEditorFn) (*GetV2VolumeListAttachedResponse, error)
}

type GetV2ImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImageIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2ImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2ImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2InstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudServiceIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2InstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2InstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2InstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudServiceApiResponse
	JSON400      *CloudServiceApiResponse
	JSON401      *CloudServiceApiResponse
	JSON500      *CloudServiceApiResponse
}

// Status returns HTTPResponse.Status
func (r PostV2InstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2InstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2InstanceTiersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudTierIEnumerableApiResponse
	JSON400      *CloudTierIEnumerableApiResponse
	JSON500      *CloudTierIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2InstanceTiersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2InstanceTiersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteV2InstanceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponse
	JSON400      *ApiResponse
	JSON403      *ApiResponse
	JSON500      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r DeleteV2InstanceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteV2InstanceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2InstanceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudServiceApiResponse
	JSON400      *CloudServiceApiResponse
	JSON403      *CloudServiceApiResponse
	JSON404      *CloudServiceApiResponse
	JSON500      *CloudServiceApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2InstanceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2InstanceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2InstanceIdPowerCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudServiceApiResponse
	JSON400      *CloudServiceApiResponse
	JSON401      *CloudServiceApiResponse
	JSON500      *CloudServiceApiResponse
}

// Status returns HTTPResponse.Status
func (r PostV2InstanceIdPowerCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2InstanceIdPowerCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2InstanceInstanceIdNetworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInstanceNetworksResponse
	JSON404      *NotFoundErrorResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetV2InstanceInstanceIdNetworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2InstanceInstanceIdNetworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2InstanceInstanceIdNetworksAttachResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttachToNetworkResponse
	JSON404      *NotFoundErrorResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostV2InstanceInstanceIdNetworksAttachResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2InstanceInstanceIdNetworksAttachResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2InstanceInstanceIdNetworksDetachResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetachFromNetworkResponse
	JSON404      *NotFoundErrorResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostV2InstanceInstanceIdNetworksDetachResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2InstanceInstanceIdNetworksDetachResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2InvoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInvoicesResponse
}

// Status returns HTTPResponse.Status
func (r GetV2InvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2InvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2InvoiceInvoiceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInvoiceResponse
	JSON404      *InvoiceNotFound
}

// Status returns HTTPResponse.Status
func (r GetV2InvoiceInvoiceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2InvoiceInvoiceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2MetalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalServiceIEnumerableApiResponse
	JSON400      *MetalServiceIEnumerableApiResponse
	JSON401      *MetalServiceIEnumerableApiResponse
	JSON500      *MetalServiceIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2MetalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2MetalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2MetalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalServiceApiResponse
	JSON400      *MetalServiceApiResponse
	JSON401      *MetalServiceApiResponse
	JSON500      *MetalServiceApiResponse
}

// Status returns HTTPResponse.Status
func (r PostV2MetalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2MetalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2MetalAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalConfigurationIEnumerableApiResponse
	JSON400      *MetalConfigurationIEnumerableApiResponse
	JSON500      *MetalConfigurationIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2MetalAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2MetalAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2MetalTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalTemplateIEnumerableApiResponse
	JSON400      *MetalTemplateIEnumerableApiResponse
	JSON401      *MetalTemplateIEnumerableApiResponse
	JSON500      *MetalTemplateIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2MetalTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2MetalTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2MetalTiersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalTierIEnumerableApiResponse
	JSON400      *MetalTierIEnumerableApiResponse
	JSON500      *MetalTierIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2MetalTiersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2MetalTiersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2MetalIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalServiceApiResponse
	JSON400      *MetalServiceApiResponse
	JSON401      *MetalServiceApiResponse
	JSON500      *MetalServiceApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2MetalIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2MetalIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2MetalIdLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogMessageIEnumerableApiResponse
	JSON400      *LogMessageIEnumerableApiResponse
	JSON401      *LogMessageIEnumerableApiResponse
	JSON500      *LogMessageIEnumerableApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2MetalIdLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2MetalIdLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2MetalIdPowerCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalServiceApiResponse
	JSON400      *MetalServiceApiResponse
	JSON403      *MetalServiceApiResponse
	JSON500      *MetalServiceApiResponse
}

// Status returns HTTPResponse.Status
func (r PostV2MetalIdPowerCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2MetalIdPowerCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2MetalIdReinstallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalServiceApiResponse
	JSON400      *MetalServiceApiResponse
	JSON401      *MetalServiceApiResponse
	JSON500      *MetalServiceApiResponse
}

// Status returns HTTPResponse.Status
func (r PostV2MetalIdReinstallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2MetalIdReinstallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2MetalIdRenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponse
	JSON400      *ApiResponse
	JSON403      *ApiResponse
	JSON500      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r PostV2MetalIdRenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2MetalIdRenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteV2NetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponse
	JSON404      *NotFoundErrorResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteV2NetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteV2NetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2NetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNetworkResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetV2NetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2NetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2NetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateNetworkResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostV2NetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2NetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV2NetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateNetworkResponse
	JSON404      *NotFoundErrorResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r PutV2NetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV2NetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2NetworkNetworkIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNetworkResponse
	JSON404      *NotFoundErrorResponse
	JSON500      *InternalErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetV2NetworkNetworkIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2NetworkNetworkIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2PriceCalculateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CalculatePriceResponse
}

// Status returns HTTPResponse.Status
func (r PostV2PriceCalculateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2PriceCalculateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResponse
}

// Status returns HTTPResponse.Status
func (r GetV2SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2UsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsageResponsePagedTswApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2UsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2UsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2UsageServiceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageResponseRowTswApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2UsageServiceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2UsageServiceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteV2VolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponse
	JSON400      *ApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r DeleteV2VolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteV2VolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2VolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVolumesResponseRecordIEnumerableApiResponse
	JSON400      *ListVolumesResponseRecordIEnumerableApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2VolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2VolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2VolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateVolumeResponseApiResponse
	JSON400      *CreateVolumeResponseApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r PostV2VolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2VolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV2VolumeAttachResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttachVolumeResponseApiResponse
	JSON400      *AttachVolumeResponseApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r PutV2VolumeAttachResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV2VolumeAttachResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV2VolumeDetachResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetachVolumeResponseApiResponse
	JSON400      *DetachVolumeResponseApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r PutV2VolumeDetachResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV2VolumeDetachResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutV2VolumeExtendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtendVolumeResponseApiResponse
	JSON400      *ExtendVolumeResponseApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r PutV2VolumeExtendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutV2VolumeExtendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2VolumeListAttachableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVolumesResponseRecordIEnumerableApiResponse
	JSON400      *ListVolumesResponseRecordIEnumerableApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2VolumeListAttachableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2VolumeListAttachableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2VolumeListAttachedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVolumesResponseRecordIEnumerableApiResponse
	JSON400      *ListVolumesResponseRecordIEnumerableApiResponse
	JSON401      *ApiResponse
	JSON404      *ApiResponse
}

// Status returns HTTPResponse.Status
func (r GetV2VolumeListAttachedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2VolumeListAttachedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetV2ImageWithResponse request returning *GetV2ImageResponse
func (c *ClientWithResponses) GetV2ImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2ImageResponse, error) {
	rsp, err := c.GetV2Image(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2ImageResponse(rsp)
}

// GetV2InstanceWithResponse request returning *GetV2InstanceResponse
func (c *ClientWithResponses) GetV2InstanceWithResponse(ctx context.Context, params *GetV2InstanceParams, reqEditors ...RequestEditorFn) (*GetV2InstanceResponse, error) {
	rsp, err := c.GetV2Instance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2InstanceResponse(rsp)
}

// PostV2InstanceWithBodyWithResponse request with arbitrary body returning *PostV2InstanceResponse
func (c *ClientWithResponses) PostV2InstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error) {
	rsp, err := c.PostV2InstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostV2InstanceApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error) {
	rsp, err := c.PostV2InstanceWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceWithResponse(ctx context.Context, body PostV2InstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error) {
	rsp, err := c.PostV2Instance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, body PostV2InstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceResponse, error) {
	rsp, err := c.PostV2InstanceWithApplicationJSONPatchPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceResponse(rsp)
}

// GetV2InstanceTiersWithResponse request returning *GetV2InstanceTiersResponse
func (c *ClientWithResponses) GetV2InstanceTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2InstanceTiersResponse, error) {
	rsp, err := c.GetV2InstanceTiers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2InstanceTiersResponse(rsp)
}

// DeleteV2InstanceIdWithResponse request returning *DeleteV2InstanceIdResponse
func (c *ClientWithResponses) DeleteV2InstanceIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteV2InstanceIdResponse, error) {
	rsp, err := c.DeleteV2InstanceId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2InstanceIdResponse(rsp)
}

// GetV2InstanceIdWithResponse request returning *GetV2InstanceIdResponse
func (c *ClientWithResponses) GetV2InstanceIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetV2InstanceIdResponse, error) {
	rsp, err := c.GetV2InstanceId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2InstanceIdResponse(rsp)
}

// PostV2InstanceIdPowerCommandWithResponse request returning *PostV2InstanceIdPowerCommandResponse
func (c *ClientWithResponses) PostV2InstanceIdPowerCommandWithResponse(ctx context.Context, id int64, params *PostV2InstanceIdPowerCommandParams, reqEditors ...RequestEditorFn) (*PostV2InstanceIdPowerCommandResponse, error) {
	rsp, err := c.PostV2InstanceIdPowerCommand(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceIdPowerCommandResponse(rsp)
}

// GetV2InstanceInstanceIdNetworksWithResponse request returning *GetV2InstanceInstanceIdNetworksResponse
func (c *ClientWithResponses) GetV2InstanceInstanceIdNetworksWithResponse(ctx context.Context, instanceId string, params *GetV2InstanceInstanceIdNetworksParams, reqEditors ...RequestEditorFn) (*GetV2InstanceInstanceIdNetworksResponse, error) {
	rsp, err := c.GetV2InstanceInstanceIdNetworks(ctx, instanceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2InstanceInstanceIdNetworksResponse(rsp)
}

// PostV2InstanceInstanceIdNetworksAttachWithBodyWithResponse request with arbitrary body returning *PostV2InstanceInstanceIdNetworksAttachResponse
func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksAttachWithBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksAttachWithBody(ctx, instanceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksAttachResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksAttachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksAttachWithApplicationWildcardPlusJSONBody(ctx, instanceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksAttachResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksAttachWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksAttach(ctx, instanceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksAttachResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksAttachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksAttachParams, body PostV2InstanceInstanceIdNetworksAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksAttachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksAttachWithApplicationJSONPatchPlusJSONBody(ctx, instanceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksAttachResponse(rsp)
}

// PostV2InstanceInstanceIdNetworksDetachWithBodyWithResponse request with arbitrary body returning *PostV2InstanceInstanceIdNetworksDetachResponse
func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksDetachWithBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksDetachWithBody(ctx, instanceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksDetachResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksDetachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksDetachWithApplicationWildcardPlusJSONBody(ctx, instanceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksDetachResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksDetachWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksDetach(ctx, instanceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksDetachResponse(rsp)
}

func (c *ClientWithResponses) PostV2InstanceInstanceIdNetworksDetachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, instanceId int64, params *PostV2InstanceInstanceIdNetworksDetachParams, body PostV2InstanceInstanceIdNetworksDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InstanceInstanceIdNetworksDetachResponse, error) {
	rsp, err := c.PostV2InstanceInstanceIdNetworksDetachWithApplicationJSONPatchPlusJSONBody(ctx, instanceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InstanceInstanceIdNetworksDetachResponse(rsp)
}

// GetV2InvoiceWithResponse request returning *GetV2InvoiceResponse
func (c *ClientWithResponses) GetV2InvoiceWithResponse(ctx context.Context, params *GetV2InvoiceParams, reqEditors ...RequestEditorFn) (*GetV2InvoiceResponse, error) {
	rsp, err := c.GetV2Invoice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2InvoiceResponse(rsp)
}

// GetV2InvoiceInvoiceIdWithResponse request returning *GetV2InvoiceInvoiceIdResponse
func (c *ClientWithResponses) GetV2InvoiceInvoiceIdWithResponse(ctx context.Context, invoiceId int64, reqEditors ...RequestEditorFn) (*GetV2InvoiceInvoiceIdResponse, error) {
	rsp, err := c.GetV2InvoiceInvoiceId(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2InvoiceInvoiceIdResponse(rsp)
}

// GetV2MetalWithResponse request returning *GetV2MetalResponse
func (c *ClientWithResponses) GetV2MetalWithResponse(ctx context.Context, params *GetV2MetalParams, reqEditors ...RequestEditorFn) (*GetV2MetalResponse, error) {
	rsp, err := c.GetV2Metal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2MetalResponse(rsp)
}

// PostV2MetalWithBodyWithResponse request with arbitrary body returning *PostV2MetalResponse
func (c *ClientWithResponses) PostV2MetalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error) {
	rsp, err := c.PostV2MetalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostV2MetalApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error) {
	rsp, err := c.PostV2MetalWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalWithResponse(ctx context.Context, body PostV2MetalJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error) {
	rsp, err := c.PostV2Metal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, body PostV2MetalApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalResponse, error) {
	rsp, err := c.PostV2MetalWithApplicationJSONPatchPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalResponse(rsp)
}

// GetV2MetalAvailabilityWithResponse request returning *GetV2MetalAvailabilityResponse
func (c *ClientWithResponses) GetV2MetalAvailabilityWithResponse(ctx context.Context, params *GetV2MetalAvailabilityParams, reqEditors ...RequestEditorFn) (*GetV2MetalAvailabilityResponse, error) {
	rsp, err := c.GetV2MetalAvailability(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2MetalAvailabilityResponse(rsp)
}

// GetV2MetalTemplatesWithResponse request returning *GetV2MetalTemplatesResponse
func (c *ClientWithResponses) GetV2MetalTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2MetalTemplatesResponse, error) {
	rsp, err := c.GetV2MetalTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2MetalTemplatesResponse(rsp)
}

// GetV2MetalTiersWithResponse request returning *GetV2MetalTiersResponse
func (c *ClientWithResponses) GetV2MetalTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2MetalTiersResponse, error) {
	rsp, err := c.GetV2MetalTiers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2MetalTiersResponse(rsp)
}

// GetV2MetalIdWithResponse request returning *GetV2MetalIdResponse
func (c *ClientWithResponses) GetV2MetalIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetV2MetalIdResponse, error) {
	rsp, err := c.GetV2MetalId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2MetalIdResponse(rsp)
}

// GetV2MetalIdLogsWithResponse request returning *GetV2MetalIdLogsResponse
func (c *ClientWithResponses) GetV2MetalIdLogsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetV2MetalIdLogsResponse, error) {
	rsp, err := c.GetV2MetalIdLogs(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2MetalIdLogsResponse(rsp)
}

// PostV2MetalIdPowerCommandWithResponse request returning *PostV2MetalIdPowerCommandResponse
func (c *ClientWithResponses) PostV2MetalIdPowerCommandWithResponse(ctx context.Context, id int64, params *PostV2MetalIdPowerCommandParams, reqEditors ...RequestEditorFn) (*PostV2MetalIdPowerCommandResponse, error) {
	rsp, err := c.PostV2MetalIdPowerCommand(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdPowerCommandResponse(rsp)
}

// PostV2MetalIdReinstallWithBodyWithResponse request with arbitrary body returning *PostV2MetalIdReinstallResponse
func (c *ClientWithResponses) PostV2MetalIdReinstallWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error) {
	rsp, err := c.PostV2MetalIdReinstallWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdReinstallResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalIdReinstallWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error) {
	rsp, err := c.PostV2MetalIdReinstallWithApplicationWildcardPlusJSONBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdReinstallResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalIdReinstallWithResponse(ctx context.Context, id int64, body PostV2MetalIdReinstallJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error) {
	rsp, err := c.PostV2MetalIdReinstall(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdReinstallResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalIdReinstallWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdReinstallApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdReinstallResponse, error) {
	rsp, err := c.PostV2MetalIdReinstallWithApplicationJSONPatchPlusJSONBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdReinstallResponse(rsp)
}

// PostV2MetalIdRenameWithBodyWithResponse request with arbitrary body returning *PostV2MetalIdRenameResponse
func (c *ClientWithResponses) PostV2MetalIdRenameWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error) {
	rsp, err := c.PostV2MetalIdRenameWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdRenameResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalIdRenameWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error) {
	rsp, err := c.PostV2MetalIdRenameWithApplicationWildcardPlusJSONBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdRenameResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalIdRenameWithResponse(ctx context.Context, id int64, body PostV2MetalIdRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error) {
	rsp, err := c.PostV2MetalIdRename(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdRenameResponse(rsp)
}

func (c *ClientWithResponses) PostV2MetalIdRenameWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, id int64, body PostV2MetalIdRenameApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2MetalIdRenameResponse, error) {
	rsp, err := c.PostV2MetalIdRenameWithApplicationJSONPatchPlusJSONBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2MetalIdRenameResponse(rsp)
}

// DeleteV2NetworkWithResponse request returning *DeleteV2NetworkResponse
func (c *ClientWithResponses) DeleteV2NetworkWithResponse(ctx context.Context, params *DeleteV2NetworkParams, reqEditors ...RequestEditorFn) (*DeleteV2NetworkResponse, error) {
	rsp, err := c.DeleteV2Network(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2NetworkResponse(rsp)
}

// GetV2NetworkWithResponse request returning *GetV2NetworkResponse
func (c *ClientWithResponses) GetV2NetworkWithResponse(ctx context.Context, params *GetV2NetworkParams, reqEditors ...RequestEditorFn) (*GetV2NetworkResponse, error) {
	rsp, err := c.GetV2Network(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2NetworkResponse(rsp)
}

// PostV2NetworkWithBodyWithResponse request with arbitrary body returning *PostV2NetworkResponse
func (c *ClientWithResponses) PostV2NetworkWithBodyWithResponse(ctx context.Context, params *PostV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error) {
	rsp, err := c.PostV2NetworkWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2NetworkResponse(rsp)
}

func (c *ClientWithResponses) PostV2NetworkWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error) {
	rsp, err := c.PostV2NetworkWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2NetworkResponse(rsp)
}

func (c *ClientWithResponses) PostV2NetworkWithResponse(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error) {
	rsp, err := c.PostV2Network(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2NetworkResponse(rsp)
}

func (c *ClientWithResponses) PostV2NetworkWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PostV2NetworkParams, body PostV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2NetworkResponse, error) {
	rsp, err := c.PostV2NetworkWithApplicationJSONPatchPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2NetworkResponse(rsp)
}

// PutV2NetworkWithBodyWithResponse request with arbitrary body returning *PutV2NetworkResponse
func (c *ClientWithResponses) PutV2NetworkWithBodyWithResponse(ctx context.Context, params *PutV2NetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error) {
	rsp, err := c.PutV2NetworkWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2NetworkResponse(rsp)
}

func (c *ClientWithResponses) PutV2NetworkWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error) {
	rsp, err := c.PutV2NetworkWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2NetworkResponse(rsp)
}

func (c *ClientWithResponses) PutV2NetworkWithResponse(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error) {
	rsp, err := c.PutV2Network(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2NetworkResponse(rsp)
}

func (c *ClientWithResponses) PutV2NetworkWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2NetworkParams, body PutV2NetworkApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2NetworkResponse, error) {
	rsp, err := c.PutV2NetworkWithApplicationJSONPatchPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2NetworkResponse(rsp)
}

// GetV2NetworkNetworkIdWithResponse request returning *GetV2NetworkNetworkIdResponse
func (c *ClientWithResponses) GetV2NetworkNetworkIdWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*GetV2NetworkNetworkIdResponse, error) {
	rsp, err := c.GetV2NetworkNetworkId(ctx, networkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2NetworkNetworkIdResponse(rsp)
}

// PostV2PriceCalculateWithBodyWithResponse request with arbitrary body returning *PostV2PriceCalculateResponse
func (c *ClientWithResponses) PostV2PriceCalculateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error) {
	rsp, err := c.PostV2PriceCalculateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2PriceCalculateResponse(rsp)
}

func (c *ClientWithResponses) PostV2PriceCalculateWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostV2PriceCalculateApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error) {
	rsp, err := c.PostV2PriceCalculateWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2PriceCalculateResponse(rsp)
}

func (c *ClientWithResponses) PostV2PriceCalculateWithResponse(ctx context.Context, body PostV2PriceCalculateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error) {
	rsp, err := c.PostV2PriceCalculate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2PriceCalculateResponse(rsp)
}

func (c *ClientWithResponses) PostV2PriceCalculateWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, body PostV2PriceCalculateApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PriceCalculateResponse, error) {
	rsp, err := c.PostV2PriceCalculateWithApplicationJSONPatchPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2PriceCalculateResponse(rsp)
}

// GetV2SearchWithResponse request returning *GetV2SearchResponse
func (c *ClientWithResponses) GetV2SearchWithResponse(ctx context.Context, params *GetV2SearchParams, reqEditors ...RequestEditorFn) (*GetV2SearchResponse, error) {
	rsp, err := c.GetV2Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2SearchResponse(rsp)
}

// GetV2UsageWithResponse request returning *GetV2UsageResponse
func (c *ClientWithResponses) GetV2UsageWithResponse(ctx context.Context, params *GetV2UsageParams, reqEditors ...RequestEditorFn) (*GetV2UsageResponse, error) {
	rsp, err := c.GetV2Usage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2UsageResponse(rsp)
}

// GetV2UsageServiceIdWithResponse request returning *GetV2UsageServiceIdResponse
func (c *ClientWithResponses) GetV2UsageServiceIdWithResponse(ctx context.Context, serviceId int64, params *GetV2UsageServiceIdParams, reqEditors ...RequestEditorFn) (*GetV2UsageServiceIdResponse, error) {
	rsp, err := c.GetV2UsageServiceId(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2UsageServiceIdResponse(rsp)
}

// DeleteV2VolumeWithBodyWithResponse request with arbitrary body returning *DeleteV2VolumeResponse
func (c *ClientWithResponses) DeleteV2VolumeWithBodyWithResponse(ctx context.Context, params *DeleteV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error) {
	rsp, err := c.DeleteV2VolumeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2VolumeResponse(rsp)
}

func (c *ClientWithResponses) DeleteV2VolumeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error) {
	rsp, err := c.DeleteV2VolumeWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2VolumeResponse(rsp)
}

func (c *ClientWithResponses) DeleteV2VolumeWithResponse(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error) {
	rsp, err := c.DeleteV2Volume(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2VolumeResponse(rsp)
}

func (c *ClientWithResponses) DeleteV2VolumeWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *DeleteV2VolumeParams, body DeleteV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteV2VolumeResponse, error) {
	rsp, err := c.DeleteV2VolumeWithApplicationJSONPatchPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2VolumeResponse(rsp)
}

// GetV2VolumeWithResponse request returning *GetV2VolumeResponse
func (c *ClientWithResponses) GetV2VolumeWithResponse(ctx context.Context, params *GetV2VolumeParams, reqEditors ...RequestEditorFn) (*GetV2VolumeResponse, error) {
	rsp, err := c.GetV2Volume(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2VolumeResponse(rsp)
}

// PostV2VolumeWithBodyWithResponse request with arbitrary body returning *PostV2VolumeResponse
func (c *ClientWithResponses) PostV2VolumeWithBodyWithResponse(ctx context.Context, params *PostV2VolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error) {
	rsp, err := c.PostV2VolumeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2VolumeResponse(rsp)
}

func (c *ClientWithResponses) PostV2VolumeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error) {
	rsp, err := c.PostV2VolumeWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2VolumeResponse(rsp)
}

func (c *ClientWithResponses) PostV2VolumeWithResponse(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error) {
	rsp, err := c.PostV2Volume(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2VolumeResponse(rsp)
}

func (c *ClientWithResponses) PostV2VolumeWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PostV2VolumeParams, body PostV2VolumeApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2VolumeResponse, error) {
	rsp, err := c.PostV2VolumeWithApplicationJSONPatchPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2VolumeResponse(rsp)
}

// PutV2VolumeAttachWithBodyWithResponse request with arbitrary body returning *PutV2VolumeAttachResponse
func (c *ClientWithResponses) PutV2VolumeAttachWithBodyWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error) {
	rsp, err := c.PutV2VolumeAttachWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeAttachResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeAttachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error) {
	rsp, err := c.PutV2VolumeAttachWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeAttachResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeAttachWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error) {
	rsp, err := c.PutV2VolumeAttach(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeAttachResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeAttachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeAttachParams, body PutV2VolumeAttachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeAttachResponse, error) {
	rsp, err := c.PutV2VolumeAttachWithApplicationJSONPatchPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeAttachResponse(rsp)
}

// PutV2VolumeDetachWithBodyWithResponse request with arbitrary body returning *PutV2VolumeDetachResponse
func (c *ClientWithResponses) PutV2VolumeDetachWithBodyWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error) {
	rsp, err := c.PutV2VolumeDetachWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeDetachResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeDetachWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error) {
	rsp, err := c.PutV2VolumeDetachWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeDetachResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeDetachWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error) {
	rsp, err := c.PutV2VolumeDetach(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeDetachResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeDetachWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeDetachParams, body PutV2VolumeDetachApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeDetachResponse, error) {
	rsp, err := c.PutV2VolumeDetachWithApplicationJSONPatchPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeDetachResponse(rsp)
}

// PutV2VolumeExtendWithBodyWithResponse request with arbitrary body returning *PutV2VolumeExtendResponse
func (c *ClientWithResponses) PutV2VolumeExtendWithBodyWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error) {
	rsp, err := c.PutV2VolumeExtendWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeExtendResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeExtendWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error) {
	rsp, err := c.PutV2VolumeExtendWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeExtendResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeExtendWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error) {
	rsp, err := c.PutV2VolumeExtend(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeExtendResponse(rsp)
}

func (c *ClientWithResponses) PutV2VolumeExtendWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, params *PutV2VolumeExtendParams, body PutV2VolumeExtendApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutV2VolumeExtendResponse, error) {
	rsp, err := c.PutV2VolumeExtendWithApplicationJSONPatchPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutV2VolumeExtendResponse(rsp)
}

// GetV2VolumeListAttachableWithResponse request returning *GetV2VolumeListAttachableResponse
func (c *ClientWithResponses) GetV2VolumeListAttachableWithResponse(ctx context.Context, params *GetV2VolumeListAttachableParams, reqEditors ...RequestEditorFn) (*GetV2VolumeListAttachableResponse, error) {
	rsp, err := c.GetV2VolumeListAttachable(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2VolumeListAttachableResponse(rsp)
}

// GetV2VolumeListAttachedWithResponse request returning *GetV2VolumeListAttachedResponse
func (c *ClientWithResponses) GetV2VolumeListAttachedWithResponse(ctx context.Context, params *GetV2VolumeListAttachedParams, reqEditors ...RequestEditorFn) (*GetV2VolumeListAttachedResponse, error) {
	rsp, err := c.GetV2VolumeListAttached(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2VolumeListAttachedResponse(rsp)
}

// ParseGetV2ImageResponse parses an HTTP response from a GetV2ImageWithResponse call
func ParseGetV2ImageResponse(rsp *http.Response) (*GetV2ImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2ImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImageIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV2InstanceResponse parses an HTTP response from a GetV2InstanceWithResponse call
func ParseGetV2InstanceResponse(rsp *http.Response) (*GetV2InstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2InstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudServiceIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostV2InstanceResponse parses an HTTP response from a PostV2InstanceWithResponse call
func ParsePostV2InstanceResponse(rsp *http.Response) (*PostV2InstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2InstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2InstanceTiersResponse parses an HTTP response from a GetV2InstanceTiersWithResponse call
func ParseGetV2InstanceTiersResponse(rsp *http.Response) (*GetV2InstanceTiersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2InstanceTiersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudTierIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CloudTierIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CloudTierIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteV2InstanceIdResponse parses an HTTP response from a DeleteV2InstanceIdWithResponse call
func ParseDeleteV2InstanceIdResponse(rsp *http.Response) (*DeleteV2InstanceIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteV2InstanceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2InstanceIdResponse parses an HTTP response from a GetV2InstanceIdWithResponse call
func ParseGetV2InstanceIdResponse(rsp *http.Response) (*GetV2InstanceIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2InstanceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2InstanceIdPowerCommandResponse parses an HTTP response from a PostV2InstanceIdPowerCommandWithResponse call
func ParsePostV2InstanceIdPowerCommandResponse(rsp *http.Response) (*PostV2InstanceIdPowerCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2InstanceIdPowerCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CloudServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2InstanceInstanceIdNetworksResponse parses an HTTP response from a GetV2InstanceInstanceIdNetworksWithResponse call
func ParseGetV2InstanceInstanceIdNetworksResponse(rsp *http.Response) (*GetV2InstanceInstanceIdNetworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2InstanceInstanceIdNetworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInstanceNetworksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2InstanceInstanceIdNetworksAttachResponse parses an HTTP response from a PostV2InstanceInstanceIdNetworksAttachWithResponse call
func ParsePostV2InstanceInstanceIdNetworksAttachResponse(rsp *http.Response) (*PostV2InstanceInstanceIdNetworksAttachResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2InstanceInstanceIdNetworksAttachResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachToNetworkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2InstanceInstanceIdNetworksDetachResponse parses an HTTP response from a PostV2InstanceInstanceIdNetworksDetachWithResponse call
func ParsePostV2InstanceInstanceIdNetworksDetachResponse(rsp *http.Response) (*PostV2InstanceInstanceIdNetworksDetachResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2InstanceInstanceIdNetworksDetachResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetachFromNetworkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2InvoiceResponse parses an HTTP response from a GetV2InvoiceWithResponse call
func ParseGetV2InvoiceResponse(rsp *http.Response) (*GetV2InvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2InvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInvoicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV2InvoiceInvoiceIdResponse parses an HTTP response from a GetV2InvoiceInvoiceIdWithResponse call
func ParseGetV2InvoiceInvoiceIdResponse(rsp *http.Response) (*GetV2InvoiceInvoiceIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2InvoiceInvoiceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInvoiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest InvoiceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetV2MetalResponse parses an HTTP response from a GetV2MetalWithResponse call
func ParseGetV2MetalResponse(rsp *http.Response) (*GetV2MetalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2MetalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalServiceIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalServiceIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MetalServiceIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalServiceIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2MetalResponse parses an HTTP response from a PostV2MetalWithResponse call
func ParsePostV2MetalResponse(rsp *http.Response) (*PostV2MetalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2MetalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2MetalAvailabilityResponse parses an HTTP response from a GetV2MetalAvailabilityWithResponse call
func ParseGetV2MetalAvailabilityResponse(rsp *http.Response) (*GetV2MetalAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2MetalAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalConfigurationIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalConfigurationIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalConfigurationIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2MetalTemplatesResponse parses an HTTP response from a GetV2MetalTemplatesWithResponse call
func ParseGetV2MetalTemplatesResponse(rsp *http.Response) (*GetV2MetalTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2MetalTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalTemplateIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalTemplateIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MetalTemplateIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalTemplateIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2MetalTiersResponse parses an HTTP response from a GetV2MetalTiersWithResponse call
func ParseGetV2MetalTiersResponse(rsp *http.Response) (*GetV2MetalTiersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2MetalTiersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalTierIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalTierIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalTierIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2MetalIdResponse parses an HTTP response from a GetV2MetalIdWithResponse call
func ParseGetV2MetalIdResponse(rsp *http.Response) (*GetV2MetalIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2MetalIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2MetalIdLogsResponse parses an HTTP response from a GetV2MetalIdLogsWithResponse call
func ParseGetV2MetalIdLogsResponse(rsp *http.Response) (*GetV2MetalIdLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2MetalIdLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogMessageIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest LogMessageIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest LogMessageIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest LogMessageIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2MetalIdPowerCommandResponse parses an HTTP response from a PostV2MetalIdPowerCommandWithResponse call
func ParsePostV2MetalIdPowerCommandResponse(rsp *http.Response) (*PostV2MetalIdPowerCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2MetalIdPowerCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2MetalIdReinstallResponse parses an HTTP response from a PostV2MetalIdReinstallWithResponse call
func ParsePostV2MetalIdReinstallResponse(rsp *http.Response) (*PostV2MetalIdReinstallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2MetalIdReinstallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MetalServiceApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2MetalIdRenameResponse parses an HTTP response from a PostV2MetalIdRenameWithResponse call
func ParsePostV2MetalIdRenameResponse(rsp *http.Response) (*PostV2MetalIdRenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2MetalIdRenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteV2NetworkResponse parses an HTTP response from a DeleteV2NetworkWithResponse call
func ParseDeleteV2NetworkResponse(rsp *http.Response) (*DeleteV2NetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteV2NetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2NetworkResponse parses an HTTP response from a GetV2NetworkWithResponse call
func ParseGetV2NetworkResponse(rsp *http.Response) (*GetV2NetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2NetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNetworkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2NetworkResponse parses an HTTP response from a PostV2NetworkWithResponse call
func ParsePostV2NetworkResponse(rsp *http.Response) (*PostV2NetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2NetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateNetworkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutV2NetworkResponse parses an HTTP response from a PutV2NetworkWithResponse call
func ParsePutV2NetworkResponse(rsp *http.Response) (*PutV2NetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV2NetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNetworkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetV2NetworkNetworkIdResponse parses an HTTP response from a GetV2NetworkNetworkIdWithResponse call
func ParseGetV2NetworkNetworkIdResponse(rsp *http.Response) (*GetV2NetworkNetworkIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2NetworkNetworkIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNetworkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostV2PriceCalculateResponse parses an HTTP response from a PostV2PriceCalculateWithResponse call
func ParsePostV2PriceCalculateResponse(rsp *http.Response) (*PostV2PriceCalculateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2PriceCalculateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CalculatePriceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV2SearchResponse parses an HTTP response from a GetV2SearchWithResponse call
func ParseGetV2SearchResponse(rsp *http.Response) (*GetV2SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV2UsageResponse parses an HTTP response from a GetV2UsageWithResponse call
func ParseGetV2UsageResponse(rsp *http.Response) (*GetV2UsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2UsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsageResponsePagedTswApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV2UsageServiceIdResponse parses an HTTP response from a GetV2UsageServiceIdWithResponse call
func ParseGetV2UsageServiceIdResponse(rsp *http.Response) (*GetV2UsageServiceIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2UsageServiceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageResponseRowTswApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteV2VolumeResponse parses an HTTP response from a DeleteV2VolumeWithResponse call
func ParseDeleteV2VolumeResponse(rsp *http.Response) (*DeleteV2VolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteV2VolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetV2VolumeResponse parses an HTTP response from a GetV2VolumeWithResponse call
func ParseGetV2VolumeResponse(rsp *http.Response) (*GetV2VolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2VolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVolumesResponseRecordIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ListVolumesResponseRecordIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostV2VolumeResponse parses an HTTP response from a PostV2VolumeWithResponse call
func ParsePostV2VolumeResponse(rsp *http.Response) (*PostV2VolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2VolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutV2VolumeAttachResponse parses an HTTP response from a PutV2VolumeAttachWithResponse call
func ParsePutV2VolumeAttachResponse(rsp *http.Response) (*PutV2VolumeAttachResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV2VolumeAttachResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AttachVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutV2VolumeDetachResponse parses an HTTP response from a PutV2VolumeDetachWithResponse call
func ParsePutV2VolumeDetachResponse(rsp *http.Response) (*PutV2VolumeDetachResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV2VolumeDetachResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetachVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DetachVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutV2VolumeExtendResponse parses an HTTP response from a PutV2VolumeExtendWithResponse call
func ParsePutV2VolumeExtendResponse(rsp *http.Response) (*PutV2VolumeExtendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutV2VolumeExtendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtendVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExtendVolumeResponseApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetV2VolumeListAttachableResponse parses an HTTP response from a GetV2VolumeListAttachableWithResponse call
func ParseGetV2VolumeListAttachableResponse(rsp *http.Response) (*GetV2VolumeListAttachableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2VolumeListAttachableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVolumesResponseRecordIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ListVolumesResponseRecordIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetV2VolumeListAttachedResponse parses an HTTP response from a GetV2VolumeListAttachedWithResponse call
func ParseGetV2VolumeListAttachedResponse(rsp *http.Response) (*GetV2VolumeListAttachedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2VolumeListAttachedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVolumesResponseRecordIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ListVolumesResponseRecordIEnumerableApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
